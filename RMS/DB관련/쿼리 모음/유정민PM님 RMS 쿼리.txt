@ 이슬비 리더님건 (RMS DB지원 게시판: [영업DB요청] 21년 HM 퇴사자 계정 전후 매출 데이터 요청)

SELECT mc.m_nm, mc.cs_m_id, mc.end_date, mc.division1, mc.division2, mc.em_nm, 
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 6 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-6', 
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 5 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-5', 	
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 4 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-4', 	
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 3 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-3', 	
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 2 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-2', 	
		 sum(if(DATE_FORMAT(mc.end_date - INTERVAL 1 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월-1', 	
		 sum(if(DATE_FORMAT(mc.end_date, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월',
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 1 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+1', 		 
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 2 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+2', 
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 3 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+3', 
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 4 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+4', 		 
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 5 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+5', 
		 sum(if(DATE_FORMAT(mc.end_date + INTERVAL 6 MONTH, '%Y-%m') = tc.pay_month, tc.pay_price, 0)) AS '퇴사월+6',
		 SUM(tc.pay_price)
FROM
(SELECT IF(m_nm='302', good_type2, m_nm) AS 'm_nm', cs_m_id, DATE_FORMAT(pay_date, '%Y-%m') AS 'pay_month', SUM(pay_price) AS 'pay_price'
FROM t_contract
WHERE del_date IS NULL AND sales_type IN ('1') AND agree_state IN ('3') AND pay_date >= '2020-07-01'
GROUP BY IF(m_nm='302', good_type2, m_nm), cs_m_id, DATE_FORMAT(pay_date, '%Y-%m')) AS tc
RIGHT OUTER JOIN
(SELECT t.m_nm, t.cs_m_id, e.end_date, e.division1, e.division2, e.em_nm
FROM
(SELECT IF(m_nm='302', good_type2, m_nm) AS 'm_nm', cs_m_id, em_seq
FROM t_contract
WHERE del_date IS NULL AND sales_type IN ('1') AND agree_state IN ('3') and
      em_seq IN ('1281','200958','1077','200967','37','1018','1610','1407','200956','1296','200955',
					  '200959','200968','1315','1563','639','921','279','1564','1502','923','1503','1378','1669','1592','1670')) as t	  	  
INNER JOIN 
(SELECT em_seq, em_nm, division1, division2, end_date 
FROM t_employee 
WHERE em_seq IN ('1281','200958','1077','200967','37','1018','1610','1407','200956','1296','200955',
'200959','200968','1315','1563','639','921','279','1564','1502','923','1503','1378','1669','1592','1670')) AS e
ON (t.em_seq = e.em_seq)
GROUP BY t.m_nm, t.cs_m_id, t.em_seq) as mc
ON(tc.m_nm = mc.m_nm AND tc.cs_m_id = mc.cs_m_id)
GROUP BY mc.m_nm, mc.cs_m_id, mc.em_nm

================================================================================================================================

@월별, 매체별, 상품별 매출 데이터

CREATE TEMPORARY TABLE IF NOT EXISTS summa
SELECT DATE_FORMAT(tc.pay_date, '%Y') AS '년', DATE_FORMAT(tc.pay_date, '%m') AS '월', 
		 tc1.kr_name AS '매체명', tc2.kr_name AS '상품명', 
		 tc3.kr_name AS '부문', tc4.kr_name AS '팀', te.em_nm AS '마케터명', sum(tc.pay_price) AS '매출액'
FROM t_contract AS tc
LEFT OUTER JOIN t_common2 AS tc1 ON (tc.m_nm = tc1.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc2 ON (tc.good_type2 = tc2.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc3 ON (tc.division1 = tc3.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc4 ON (tc.division2 = tc4.cm2_seq)
LEFT OUTER JOIN t_employee AS te ON (tc.em_seq = te.em_seq)
WHERE tc.del_date IS NULL AND tc.sales_type IN ('1') AND tc.agree_state IN ('3') AND tc.pay_date BETWEEN '2011-01-01' AND '2011-12-31'
GROUP BY DATE_FORMAT(tc.pay_date, '%Y-%m'), tc.m_nm, tc.good_type2, tc.division1, tc.division2, tc.em_seq


DROP TABLE summa


insert INTO summa
SELECT DATE_FORMAT(tc.pay_date, '%Y') AS '년', DATE_FORMAT(tc.pay_date, '%m') AS '월', 
		 tc1.kr_name AS '매체명', tc2.kr_name AS '상품명', 
		 tc3.kr_name AS '부문', tc4.kr_name AS '팀', te.em_nm AS '마케터명', sum(tc.pay_price) AS '매출액'
FROM t_contract AS tc
LEFT OUTER JOIN t_common2 AS tc1 ON (tc.m_nm = tc1.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc2 ON (tc.good_type2 = tc2.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc3 ON (tc.division1 = tc3.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc4 ON (tc.division2 = tc4.cm2_seq)
LEFT OUTER JOIN t_employee AS te ON (tc.em_seq = te.em_seq)
WHERE tc.del_date IS NULL AND tc.sales_type IN ('1') AND tc.agree_state IN ('3') AND tc.pay_date BETWEEN '2021-01-01' AND '2021-12-31'
GROUP BY DATE_FORMAT(tc.pay_date, '%Y-%m'), tc.m_nm, tc.good_type2, tc.division1, tc.division2, tc.em_seq


SELECT *
FROM summa


================================================================================================================================


/*매체별 계정별 1년 누적 매출 데이터(네이버는 상품별)*/
SELECT tc.m_nm1, tc2.kr_name, tc.cs_seq, tcr.cs_nm, tc.cs_m_id, tc.sum_pay_price, la.em_seq, te.em_nm, te.division1, tc2_1.kr_name, te.division2, tc2_2.kr_name
FROM (SELECT IF(m_nm IN ('302'), good_type2, m_nm) AS 'm_nm', IF(m_nm IN ('264', '302'), good_type2, m_nm) AS 'm_nm1', cs_seq, cs_m_id, SUM(pay_price) AS 'sum_pay_price'
		FROM t_contract
		WHERE del_date IS NULL AND sales_type IN ('1') AND agree_state IN ('3') AND pay_date BETWEEN '2021-01-01' AND '2021-12-31'
		GROUP BY IF(m_nm IN ('264', '302'), good_type2, m_nm), cs_m_id) AS tc
		
LEFT OUTER JOIN (SELECT tmmd.cs_seq AS 'cs_seq', IF(tmmd.m_nm IN ('302'), tmmd.good_type2, tmmd.m_nm) AS 'm_nm', tmmd.cs_m_id AS 'cs_m_id', tmmd.em_seq AS 'em_seq'
FROM t_contract AS tmmd,
(SELECT IF(m_nm IN ('302'), good_type2, m_nm) AS 'm_nm', cs_m_id, max(pay_date) AS 'pay_date'
FROM t_contract
WHERE del_date IS NULL AND sales_type IN ('1') AND agree_state IN ('3') AND pay_date BETWEEN '2020-01-01' AND '2021-12-31'
GROUP BY IF(m_nm IN ('302'), good_type2, m_nm), cs_m_id) AS latest
WHERE tmmd.del_date IS NULL AND tmmd.sales_type IN ('1') AND tmmd.agree_state IN ('3') AND tmmd.pay_date BETWEEN '2020-01-01' AND '2021-12-31' AND 
      IF(tmmd.m_nm IN ('302'), tmmd.good_type2, tmmd.m_nm) = latest.m_nm AND tmmd.cs_m_id = latest.cs_m_id AND tmmd.pay_date = latest.pay_date
GROUP BY tmmd.cs_seq, IF(tmmd.m_nm IN ('302'), tmmd.good_type2, tmmd.m_nm), tmmd.cs_m_id, tmmd.em_seq) AS la
ON (tc.m_nm = la.m_nm AND tc.cs_m_id = la.cs_m_id)

LEFT OUTER JOIN t_common2 AS tc2 ON(tc.m_nm1 = tc2.cm2_seq)
LEFT OUTER JOIN t_customer AS tcr ON (tc.cs_seq = tcr.cs_seq)
LEFT OUTER JOIN t_employee AS te ON (la.em_seq = te.em_seq)
LEFT OUTER JOIN t_common2 AS tc2_1 ON(te.division1 = tc2_1.cm2_seq)
LEFT OUTER JOIN t_common2 AS tc2_2 ON(te.division2 = tc2_2.cm2_seq)




================================================================================================================================


@광고주SIDE 키워드 데이터

/*키워드데이터*/
SELECT kg.keyword_group AS '검색용 필드', t1.kr_name AS '신규1차업종', t2.kr_name AS '신규2차업종', c.cs_nm AS '광고주명', k.matching_id AS '광고계정',
       (case k.product_type 
		  when 0 then '그 외'
		  when 1 then '파워링크'		 
		  when 2 then '쇼핑검색'		 
		  when 3 then '파워컨텐츠'		 
		  when 4 then '브랜드검색'		
		  when 6 then '플레이스'
		  ELSE ''
		  end) AS '상품명', k.keyword AS ' 키워드', e.em_nm AS '담당자명',
		  k.impression_cnt AS '노출수', k.click_cnt AS '클릭수', k.cost AS '광고비', k.ctr AS '클릭율', k.conversion_cnt AS '전환수', k.conversion_amnt AS '전환매출'
FROM (SELECT * FROM t_keyword_filter_month WHERE pay_date = '2021-11') AS k
LEFT OUTER JOIN (SELECT cm2_seq, kr_name FROM hm.t_common2 WHERE cm1_seq = 25) AS t1
ON k.cs_type_new1 = t1.cm2_seq
LEFT OUTER JOIN (SELECT cm2_seq, kr_name FROM hm.t_common2 WHERE cm1_seq = 26) AS t2
ON k.cs_type_new2 = t2.cm2_seq
LEFT OUTER JOIN (SELECT cs_seq, cs_nm FROM hm.t_customer WHERE del_date IS NULL) AS c
ON k.cs_seq = c.cs_seq
LEFT OUTER JOIN (SELECT em_seq, em_nm FROM hm.t_employee WHERE del_date IS NULL) AS e
ON k.em_seq = e.em_seq
LEFT OUTER JOIN (SELECT cs_seq, GROUP_CONCAT(DISTINCT keyword separator '|') AS 'keyword_group' FROM t_keyword_filter_month WHERE pay_date = '2021-11' GROUP BY cs_seq) as kg
ON k.cs_seq = kg.cs_seq

================================================================================================================================
@수집 데이터 체킹 쿼리
/*매체수집체크쿼리*/
SELECT 
d1.pay_date '기간',
d1.media_code '매체코드',
getMediaName(d1.media_code) '매체명',
d0.message '매체수집결과',
d4.담당자매칭계정수,
d4.담당자미매칭계정수,
d1.sales_cnt '수집된 계정 중 0초과 데이터발생 계정수',
d2.sales_cnt '전일',
d1.sales_cnt-d2.sales_cnt '차이',
/*concat(ROUND((d1.sales_cnt-d2.sales_cnt)/d2.sales_cnt*100, 2), '%') AS '증감율',*/
d3.sales_cnt '전주동요일',
d1.sales_cnt-d3.sales_cnt '차이',
/*concat(ROUND((d1.sales_cnt-d3.sales_cnt)/d3.sales_cnt*100, 2), '%') AS '증감율',*/
d1.total_cost 'cost 합',
d2.total_cost '전일',
d1.total_cost-d2.total_cost '차이',
concat(ROUND((d1.total_cost-d2.total_cost)/d2.total_cost*100, 2), '%') AS '증감율',
d3.total_cost '전주동요일',
d1.total_cost-d3.total_cost '차이',
concat(ROUND((d1.total_cost-d3.total_cost)/d3.total_cost*100, 2), '%') AS '증감율'
FROM
(SELECT pay_date, media_code, message
FROM t_media_process
WHERE pay_date = date_add(CURDATE(), INTERVAL-1 DAY)
AND media_code NOT IN ('99999', '0')) AS d0
LEFT OUTER JOIN (SELECT *
FROM t_advertiser_result_check
WHERE pay_date = date_add(CURDATE(), INTERVAL-1 DAY)) AS d1
ON d0.media_code = d1.media_code
LEFT OUTER JOIN (select *
FROM t_advertiser_result_check
WHERE pay_date = date_add(CURDATE(), INTERVAL-2 DAY)) AS d2
ON d0.media_code = d2.media_code
LEFT OUTER JOIN (select *
FROM t_advertiser_result_check
WHERE pay_date = date_add(CURDATE(), INTERVAL-8 DAY)) AS d3
ON d0.media_code = d3.media_code
LEFT OUTER JOIN (SELECT media_code, COUNT(if(em_seq != 'none', 1, NULL)) AS '담당자매칭계정수', COUNT(if(em_seq = 'none', 1, NULL)) AS '담당자미매칭계정수'
FROM t_report_daily
WHERE pay_date = date_add(CURDATE(), INTERVAL-1 DAY)
GROUP BY media_code) AS d4
ON d0.media_code = d4.media_code
ORDER BY (d1.sales_cnt-d2.sales_cnt)/d2.sales_cnt*100;


/*매체별, 계정별, 상품별 데이터 확인*/
SELECT *
FROM(
SELECT d1.media_code AS '매체명', d1.em_seq AS '담당자명', d1.cs_seq AS '광고주코드', 
       d1.cs_nm AS '광고주명', d1.matching_id AS '광고계정', d1.product_type AS '광고상품명',
       IFNULL(d1.cost, 0) AS '전일광고비', IFNULL(d2.cost, 0) AS '전전일광고비', (IFNULL(d1.cost, 0) - IFNULL(d2.cost, 0)) AS '차이'
FROM 
(SELECT *
FROM t_report_daily
WHERE pay_date = date_add(CURDATE(), INTERVAL-1 DAY) AND media_code = '7'
GROUP BY matching_id, product_type) d1
LEFT OUTER JOIN(SELECT *
FROM t_report_daily
WHERE pay_date = date_add(CURDATE(), INTERVAL-2 DAY) AND media_code = '7'
GROUP BY matching_id, product_type) d2
ON (d1.matching_id = d2.matching_id AND d1.product_type = d2.product_type)
UNION
SELECT d2.media_code AS '매체명', d2.em_seq AS '담당자명', d2.cs_seq AS '광고주코드', 
       d2.cs_nm AS '광고주명', d2.matching_id AS '광고계정', d2.product_type AS '광고상품명',
       IFNULL(d1.cost, 0) AS '전일광고비', IFNULL(d2.cost, 0) AS '전전일광고비', (IFNULL(d1.cost, 0) - IFNULL(d2.cost, 0)) AS '차이'
FROM 
(SELECT *
FROM t_report_daily
WHERE pay_date = date_add(CURDATE(), INTERVAL-1 DAY) AND media_code = '7'
GROUP BY matching_id, product_type) d1
RIGHT OUTER JOIN(SELECT *
FROM t_report_daily
WHERE pay_date = date_add(CURDATE(), INTERVAL-2 DAY) AND media_code = '7'
GROUP BY matching_id, product_type) d2
ON (d1.matching_id = d2.matching_id AND d1.product_type = d2.product_type)) F
ORDER BY F.차이 DESC


/*RMS 계정수, 매출 확인*/
SELECT *
FROM t_contract
WHERE del_date is NULL AND sales_type=1 AND agree_state IN (2, 3) 
      AND pay_date = date_add(CURDATE(), INTERVAL-2 DAY) AND good_type2 = '847'
GROUP BY cs_m_id
================================================================================================================================





/*result table 쿼리*/
select * from
                (select sum(cost) as total_cost from hm.t_report_daily where pay_date=@pay_date and media_code=@media_code) as total_cost,
                (select count(distinct matching_id) as r_daily_cnt from hm.t_report_daily where pay_date=@pay_date and media_code=@media_code) as r_daily_cnt,
                (select count(distinct matching_id) as r_week_cnt from hm.t_report_week where from_date=@from_date and to_date=@to_date and media_code=@media_code) as r_week_cnt,
                (select count(distinct matching_id) as r_month_cnt from hm.t_report_month where pay_date=%s and media_code=@media_code) as r_month_cnt,
                (select count(distinct matching_id) as k_daily_cnt from t_keyword_filter_daily where pay_date=@pay_date) as k_daily_cnt,
                (select count(distinct matching_id) as k_week_cnt from t_keyword_filter_week where from_date=@from_date and to_date=@to_date) as k_week_cnt,
                (select count(distinct matching_id) as k_month_cnt from t_keyword_filter_month where pay_date=%s) as k_month_cnt,
                (select count(distinct matching_id) as sales_cnt from hm.t_report_daily where pay_date=@pay_date and media_code=@media_code and
                (impression_cnt > 0 or click_cnt > 0 or cost > 0 or conversion_cnt > 0 or conversion_amnt > 0)) as sales_cnt


/*요약*/
/*매체별 성과정보 합계*/
SELECT IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_month
WHERE pay_date = '2021-09' AND cs_seq = '38386'
/*매체별 성과정보*/
SELECT IF(media_code='5', getProductName(product_type), getMediaName(media_code)) AS '매체', 
		 IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_month
WHERE pay_date = '2021-09' AND cs_seq = '38386'
GROUP BY if(media_code='5', product_type, media_code)
ORDER BY SUM(cost) DESC

--------------------------------------------------------------------------------------------------------
/*월별 합계*/
SELECT IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_month
WHERE pay_date BETWEEN '2020-09' AND '2021-09' AND cs_seq = '38386'
/*월별*/
SELECT pay_date AS '날짜', 
		 IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_month
WHERE pay_date BETWEEN '2020-09' AND '2021-09' AND cs_seq = '38386'
GROUP BY pay_date
ORDER BY pay_date DESC
--------------------------------------------------------------------------------------------------------
/*주차별 성과정보 합계*/
SELECT IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_week
WHERE from_date BETWEEN '2021-08-30' AND '2021-09-27' AND cs_seq = '38386'

/*주차별 성과정보*/
SELECT CONCAT(from_date, ' ~ ', to_date) AS '날짜', 
		 IFNULL(format(SUM(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(SUM(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(SUM(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(SUM(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(SUM(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_week
WHERE from_date BETWEEN '2021-08-30' AND '2021-09-27' AND cs_seq = '38386'
GROUP BY from_date
ORDER BY from_date desc
--------------------------------------------------------------------------------------------------------
/*네이버_파워링크 요일별 평균 성과정보 일평균*/
SELECT ifnull(format(avg(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(avg(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(avg(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(avg(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(avg(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_daily
WHERE pay_date BETWEEN '2021-09-01' AND '2021-09-31' and cs_seq = '38386'

/*네이버_파워링크 요일별 평균 성과정보*/
SELECT (case when DAYOFWEEK(pay_date) = 2 then '월' 
             when DAYOFWEEK(pay_date) = 3 then '화' 
				 when DAYOFWEEK(pay_date) = 4 then '수' 
				 when DAYOFWEEK(pay_date) = 5 then '목' 
				 when DAYOFWEEK(pay_date) = 6 then '금' 
				 when DAYOFWEEK(pay_date) = 7 then '토' 
				 when DAYOFWEEK(pay_date) = 1 then '일' 
				 ELSE '합계'
				 END) AS '날짜',
		 ifnull(format(avg(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(avg(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(avg(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(avg(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(avg(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_daily
WHERE pay_date BETWEEN '2021-09-01' AND '2021-09-31' AND cs_seq = '38386'
GROUP BY DAYOFWEEK(pay_date)
ORDER BY FIELD(DAYOFWEEK(pay_date), 2, 3, 4, 5, 6, 7, 1)
--------------------------------------------------------------------------------------------------------
/*네이버_파워링크 일자별 성과정보 합계*/
SELECT ifnull(format(sum(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(sum(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(sum(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(sum(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(sum(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_daily
WHERE pay_date BETWEEN '2021-09-01' AND '2021-09-31' AND cs_seq = '38386'
/*네이버_파워링크 일자별 성과정보*/
SELECT pay_date AS '날짜',
       ifnull(format(sum(impression_cnt), 0), "-") AS '노출수', 
		 ifnull(format(sum(click_cnt), "-"), 0) AS '클릭수', 
       ifnull(concat(round((SUM(click_cnt)/SUM(impression_cnt)*100),2),'%'), "-") AS '클릭율', 
       ifnull(format(round(sum(cost)), 0), "-") AS '광고비', 
		 ifnull(format(round(SUM(cost)/SUM(click_cnt)), 0), "-") AS '클릭당 비용(PPC)', 
		 ifnull(format(sum(conversion_cnt), 0), "-") AS '전환수', 
		 ifnull(concat(round((SUM(conversion_cnt)/SUM(click_cnt)*100),2),'%'), "-") AS '전환율(CVR)',
       ifnull(format(round(SUM(cost)/SUM(conversion_cnt)), 0), "-") AS '전환당 비용(CPS)', 
		 ifnull(format(sum(conversion_amnt), 0), "-") AS '전환매출', 
		 ifnull(format(round(SUM(conversion_amnt)/SUM(conversion_cnt)), 0), "-") AS '전환단가', 
		 ifnull(concat(round((SUM(conversion_amnt)/SUM(cost)*100),2),'%'), "-") AS '광고수익율(ROAS)'
FROM t_report_daily
WHERE pay_date BETWEEN '2021-09-01' AND '2021-09-31' AND cs_seq = '38386'
GROUP BY pay_date
ORDER BY pay_date desc
--------------------------------------------------------------------------------------------------------


=====================================================================================
hm담당자별 운영매체와 상품,  특정월 매출 썸
SELECT getcomkrname(division1), getcomkrname(division2), getEmkrName(em_seq), GROUP_CONCAT(DISTINCT getcomkrname(m_nm)), GROUP_CONCAT(DISTINCT getcomkrname(good_type2)), SUM(pay_price)
FROM t_contract
WHERE del_date is NULL AND sales_type=1 AND agree_state IN (2, 3) AND pay_date BETWEEN '2021-09-01' AND '2021-09-31'
GROUP BY division1, division2, em_seq

=====================================================================================
21년 신규인입건 중 rms 정보상 11번가 미등록 계정
SELECT getCsKrName(tcm.cs_seq) AS '광고주명', getcomkrname(IF(tcm.m_nm='302', tcm.good_type2, tcm.m_nm)) AS '매체명', tcm.cs_m_id AS '광고계정', tcm.reg_date AS '인입일', 
       getEmkrName(tcm.reg_emp) AS '마케터명', tc.cs_num AS '사업자번호', IF(tcm.m_nm='302', tcm.good_type2, tcm.m_nm) AS 'm_nm', tcm.del_date
FROM t_customer_md tcm RIGHT OUTER JOIN (SELECT cs_seq, cs_num 
													  FROM t_customer
													  WHERE reg_date >= '2021-01-01' AND del_date is null) tc ON (tcm.cs_seq = tc.cs_seq)
WHERE getcomkrname(IF(tcm.m_nm='302', tcm.good_type2, tcm.m_nm)) IS NOT NULL 
      AND tc.cs_num NOT IN (SELECT atc.cs_num 
								    FROM t_customer_md atcm LEFT OUTER JOIN t_customer atc ON (atcm.cs_seq = atc.cs_seq) 
								    WHERE atcm.m_nm = '808' AND atcm.del_date IS null)
		AND tcm.del_date IS null


SELECT IF(m_nm='302', good_type2, m_nm) AS 'm_nm', cs_m_id, SUM(pay_price)
FROM t_contract
WHERE del_date is NULL AND sales_type=1 AND agree_state IN (2, 3) AND pay_date >= '2021-01-01'
GROUP BY IF(m_nm='302', good_type2, m_nm), cs_m_id

=====================================================================================
[광고사업3부문 김유리] RMS/AMS 데이터 지원 요청의 건
/*RMS매출데이터*/
SELECT max(cs_seq), getcomkrname(IF(m_nm='302', good_type2, m_nm)) AS m_nm, cs_m_id, em_seq, CONCAT(YEAR(pay_date),'-',month(pay_date)) AS pay_month, sum(pay_price)
FROM t_contract
WHERE del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
      AND pay_date BETWEEN '2021-01-01' AND '2021-09-31' 
      AND em_seq IN (SELECT em_seq FROM t_employee WHERE division1 = '928')
GROUP BY IF(m_nm='302', good_type2, m_nm), cs_m_id, em_seq, CONCAT(YEAR(pay_date),'-',month(pay_date))
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*AMS매출데이터*/
SELECT max(cs_seq), getMediaName(media_code), matching_id, em_seq, pay_date, 
       SUM(cost), SUM(impression_cnt), SUM(click_cnt), SUM(IFNULL(conversion_cnt, 0)), SUM(IFNULL(conversion_amnt, 0))
from t_report_month
WHERE pay_date BETWEEN '2021-01' AND '2021-09'
      AND em_seq IN (SELECT em_seq FROM t_employee WHERE division1 = '928')
GROUP BY media_code, matching_id, em_seq, cspay_date
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*현재 부분, 팀을 출력하는 쿼리*/
SELECT em_seq, getcomkrname(division1), getcomkrname(division2), em_nm
FROM t_employee
WHERE em_seq IN (SELECT em_seq FROM t_employee WHERE division1 = '928')
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*광고주명*/
SELECT cs_seq, cs_nm, getcomkrname(cs_type_new1)
FROM t_customer
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*확인용쿼리*/
SELECT getMediaName(media_code), matching_id, getEmkrName(em_seq), em_seq, pay_date, cost
from t_report_month
WHERE matching_id = 'LD478382'

=====================================================================================

[광고사업1부문 1팀 이은주] 퇴사자 매출 DB 요청의 건 2021. 9. 10. (금) 10:56

/*최신담당자 구하는 쿼리*/

CREATE TEMPORARY TABLE IF NOT EXISTS ya /*매체의 계정별 MAX pay_date를 구하는 쿼리*/
( 
INDEX `m_nm1` (m_nm1),
INDEX `cs_m_id` (cs_m_id)
)
SELECT IF(m_nm='302', good_type2, m_nm) AS m_nm1, cs_m_id, MAX(pay_date) AS 'pay_date'
FROM t_contract
WHERE (pay_date BETWEEN '2020-10-01' AND '2021-08-31') AND del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
GROUP BY m_nm1, cs_m_id


CREATE TEMPORARY TABLE IF NOT EXISTS yb /*위 MAX pay_date에 해당하는 담당자를 구하는 쿼리*/
( 
INDEX `m_nm1` (m_nm1),
INDEX `cs_m_id` (cs_m_id)
)
SELECT a.m_nm1, a.cs_m_id, a.division1, a.division2, a.em_seq
FROM (SELECT IF(m_nm='302', good_type2, m_nm) AS m_nm1, cs_m_id, pay_date, division1, division2, em_seq
		FROM t_contract
		WHERE (pay_date BETWEEN '2020-10-01' AND '2021-08-31') AND del_date is NULL AND sales_type=1 and agree_state IN (2, 3)) AS a, ya AS b
WHERE a.m_nm1 = b.m_nm1 AND a.cs_m_id = b.cs_m_id AND a.pay_date = b.pay_date
GROUP BY a.m_nm1, a.cs_m_id, a.division1, a.division2, a.em_seq

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
/*264: NAVER, 41: KAKAO, 496: 이베이, 808: 11번가*/
/*계정의 피이관일을 구하는 쿼리*/

CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_transfer_id /*최신 이관일 임시테이블 생성*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_transfer_id a, (select m_nm, cs_m_id, MAX(transfer_date2) AS max_date 
											FROM t_real_real_transfer_id
											WHERE del_date IS NULL AND state = '완료' AND transfer_date2 between '2020-10-01' AND '2021-08-31' AND m_nm IN ('264', '41')
											GROUP BY m_nm, cs_m_id) b 
WHERE a.transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) 
      and a.del_date IS NULL AND a.state = '완료' AND a.transfer_date2 between '2020-10-01' AND '2021-08-31' AND a.m_nm IN ('264', '41')
GROUP BY a.m_nm, a.cs_m_id


CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_r_transfer_id /*최신 피이관일 임시테이블 생성*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_r_transfer_id a, (select m_nm, cs_m_id, MAX(r_transfer_date2) AS max_date 
											  FROM t_real_real_r_transfer_id 
											  WHERE del_date IS NULL AND state = '완료' AND r_transfer_date2 between '2020-10-01' AND '2021-08-31' AND m_nm IN ('264', '41')
											  GROUP BY m_nm, cs_m_id) b 
WHERE a.r_transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) 
      and a.del_date IS NULL AND a.state = '완료' AND a.r_transfer_date2 between '2020-10-01' AND '2021-08-31' AND a.m_nm IN ('264', '41')
GROUP BY a.m_nm, a.cs_m_id

CREATE TEMPORARY TABLE IF NOT EXISTS r_transfer /*최종 피이관 계정 추출(최신 이관, 피이관 테이블 비교)*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id) AS 'key', a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM max_t_real_real_r_transfer_id a LEFT OUTER JOIN max_t_real_real_transfer_id b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id
WHERE a.r_transfer_date2 > b.transfer_date2 OR b.transfer_date2 IS NULL

DROP TABLE c_r_transfer;


CREATE TEMPORARY TABLE IF NOT EXISTS aug_pay_price /*2021-08 매출데이터*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(m_nm, cs_m_id), m_nm, cs_m_id, SUM(pay_price) AS pay_price, MAX(pay_date) AS pay_date
FROM t_contract
WHERE pay_date BETWEEN '2021-08-01' AND '2021-08-31' AND m_nm IN (264, 41) and del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
GROUP BY m_nm, cs_m_id


CREATE TEMPORARY TABLE IF NOT EXISTS final /*최종피이관계정(이관, 피이관 테이블 비교하여 최종 피이관 계정 추출 후 이중 8월에 매출 미발생 계정을 최종 피이관으로 간주) */
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT a.*, b.pay_price, IFNULL(b.pay_date, 0)
FROM r_transfer a LEFT OUTER JOIN aug_pay_price b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id
WHERE b.pay_price IS NULL OR a.r_transfer_date2 > IFNULL(b.pay_date, 0)

SELECT *
FROM final

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
/*결과 쿼리*/

CREATE TEMPORARY TABLE IF NOT EXISTS t_contract1 /*조인을 위해 매체 코드 분리한 t_contract 임시 테이블*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT IF(m_nm='302', good_type2, m_nm) AS m_nm, good_type2, em_seq, cs_m_id, cs_seq, pay_date, pay_price, del_date, sales_type, agree_state
FROM t_contract
WHERE pay_date BETWEEN '2020-10-01' AND '2021-08-31' AND del_date is NULL AND sales_type=1 and agree_state IN (2, 3) 


CREATE TEMPORARY TABLE IF NOT EXISTS latest_id /*퇴사자가 담담했던 계정*/
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT tcb.m_nm, tcb.cs_m_id, te.em_seq, te.division1, te.division2, te.end_date, te.join_date
FROM t_contract1 AS tcb LEFT OUTER JOIN (SELECT em_seq, division1, division2, end_date, join_date FROM t_employee WHERE end_date >= '2021-01-01') AS te ON tcb.em_seq = te.em_seq
WHERE del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
      AND tcb.em_seq = te.em_seq
GROUP BY tcb.m_nm, tcb.cs_m_id, te.em_seq


/*결과 쿼리*/
SELECT getEmkrName(te.em_seq) AS '퇴사자명', getcomkrname(te.division1) AS '부문', getcomkrname(te.division2) AS '팀', 
       CONCAT(cast(TIMESTAMPDIFF(MONTH, te.join_date, te.end_date) AS char), '개월') AS '재직기간' ,te.join_date AS '입사일', te.end_date AS '퇴사일', MONTH(te.end_date) AS '퇴사월', 
		 getcomkrname(tcb.m_nm) AS '매체명', tcb.cs_m_id AS '광고계정', getCsKrName(tcb.cs_seq) AS '광고주명',
		 getEmkrName(r.em_seq) AS '최근담당자명', getcomkrname(r.division1) AS '최근부문', getcomkrname(r.division2) AS '최근팀',
		 concat(year(f.r_transfer_date2),'-',MONTH(f.r_transfer_date2)) AS '피이관월',
		 CONCAT(YEAR(tcb.pay_date),'-',month(tcb.pay_date)) AS '매출월', SUM(tcb.pay_price) AS '매출' 
FROM t_contract1 AS tcb 
     LEFT OUTER JOIN latest_id AS te ON tcb.m_nm = te.m_nm AND tcb.cs_m_id = te.cs_m_id  /*퇴사자정보*/
     LEFT OUTER JOIN final AS f ON tcb.m_nm = f.m_nm AND tcb.cs_m_id = f.cs_m_id /*피이관월*/
	  LEFT OUTER JOIN yb AS r ON tcb.m_nm = r.m_nm1 AND tcb.cs_m_id = r.cs_m_id /*최근담당자*/
WHERE tcb.m_nm = te.m_nm AND tcb.cs_m_id = te.cs_m_id
GROUP BY te.em_seq, tcb.m_nm, tcb.cs_m_id, CONCAT(YEAR(tcb.pay_date),'-',month(tcb.pay_date));


=====================================================================================




요청메일제목: 피이관계정리스트 도출의 건 (받은날짜 :2021. 8. 23. (월) 15:29)
------------------------------------------------------------------------------------------------------------------------------
/*이관 테이블*/
SELECT CONCAT(m_nm, cs_m_id), division1, division2, em_seq, m_nm, cs_m_id, transfer_date2, CONCAT(m_nm, cs_m_id)
FROM t_real_real_transfer_id
WHERE del_date IS NULL AND state = '완료' AND transfer_date2 >= '2018-01-01'

/*피이관 테이블*/
SELECT CONCAT(m_nm, cs_m_id), division1, division2, em_seq, m_nm, cs_m_id, r_transfer_date2
FROM t_real_real_r_transfer_id 
WHERE del_date IS NULL AND state = '완료' AND r_transfer_date2 >= '2018-01-01'
------------------------------------------------------------------------------------------------------------------------------
/*최신 이관일 임시테이블 생성*/
/*264: NAVER, 41: KAKAO, 496: 이베이, 808: 11번가*/
CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_transfer_id
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_transfer_id a,
(select m_nm, cs_m_id, MAX(transfer_date2) AS max_date 
FROM t_real_real_transfer_id
WHERE del_date IS NULL AND state = '완료' AND transfer_date2 between '2018-01-01' AND '2021-08-26' AND m_nm IN ('264', '41', '496', '808')
GROUP BY m_nm, cs_m_id) b 
WHERE a.transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) 
      and a.del_date IS NULL AND a.state = '완료' AND a.transfer_date2 between '2018-01-01' AND '2021-08-26' AND a.m_nm IN ('264', '41', '496', '808')
GROUP BY a.m_nm, a.cs_m_id

/*최신 피이관일 임시테이블 생성*/
CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_r_transfer_id
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_r_transfer_id a,
(select m_nm, cs_m_id, MAX(r_transfer_date2) AS max_date 
FROM t_real_real_r_transfer_id 
WHERE del_date IS NULL AND state = '완료' AND r_transfer_date2 between '2018-01-01' AND '2021-08-26' AND m_nm IN ('264', '41', '496', '808')
GROUP BY m_nm, cs_m_id) b 
WHERE a.r_transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) 
      and a.del_date IS NULL AND a.state = '완료' AND a.r_transfer_date2 between '2018-01-01' AND '2021-08-26' AND a.m_nm IN ('264', '41', '496', '808')
GROUP BY a.m_nm, a.cs_m_id

/*생성확인*/
SELECT *
FROM max_t_real_real_transfer_id

SELECT *
FROM max_t_real_real_r_transfer_id

------------------------------------------------------------------------------------------------------------------------------
/*최종 피이관 계정 추출*/
CREATE TEMPORARY TABLE IF NOT EXISTS r_transfer
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id) AS 'key', a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM max_t_real_real_r_transfer_id a LEFT OUTER JOIN max_t_real_real_transfer_id b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id
WHERE a.r_transfer_date2 > b.transfer_date2 OR b.transfer_date2 IS NULL

/*확인용 최종 피이관 계정 테이블*/
CREATE TEMPORARY TABLE IF NOT EXISTS c_r_transfer
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id) AS 'key', a.m_nm, a.cs_m_id, a.r_transfer_date2 AS '최신 피이관일', a.division1, a.division2, a.em_seq, b.transfer_date2 AS '최신 이관일'
FROM max_t_real_real_r_transfer_id a LEFT OUTER JOIN max_t_real_real_transfer_id b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id

/*생성확인*/
SELECT *
FROM r_transfer

SELECT *
FROM c_r_transfer

------------------------------------------------------------------------------------------------------------------------------
/*2021-08 매출데이터*/
/*264: NAVER, 41: KAKAO, 496: 이베이, 808: 11번가*/
CREATE TEMPORARY TABLE IF NOT EXISTS aug_pay_price
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(m_nm, cs_m_id), m_nm, cs_m_id, SUM(pay_price) AS pay_price
FROM t_contract
WHERE pay_date BETWEEN '2021-08-01' AND '2021-08-31' AND m_nm IN (264, 41, 496, 808) and del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
GROUP BY m_nm, cs_m_id

/*생성확인*/
SELECT *
FROM aug_pay_price

------------------------------------------------------------------------------------------------------------------------------
/*최종피이관계정(이관, 피이관 테이블 비교하여 최종 피이관 계정 추출 후 이중 8월에 매출 미발생 계정을 최종 피이관으로 간주) */
CREATE TEMPORARY TABLE IF NOT EXISTS final
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT a.*
FROM r_transfer a LEFT OUTER JOIN aug_pay_price b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id
WHERE b.pay_price IS NULL OR a.r_transfer_date2 BETWEEN '2021-08-01' AND '2021-08-31'

SELECT *
FROM final
------------------------------------------------------------------------------------------------------------------------------

/*최종피이관계정 나누기*/

SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2018-01-01' AND '2018-01-31'
SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2018-07-01' AND '2018-12-31'

SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2019-01-01' AND '2019-06-31'
SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2019-07-01' AND '2019-12-31'

SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2020-01-01' AND '2020-06-31'
SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2020-07-01' AND '2020-12-31'

SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2021-01-01' AND '2021-04-31'
SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2021-05-01' AND '2021-08-31'

------------------------------------------------------------------------------------------------------------------------------


/*264: NAVER, 41: KAKAO, 496: 이베이, 808: 11번가*/
CREATE TEMPORARY TABLE IF NOT EXISTS final_1
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT tcb.cs_seq, f.m_nm, f.cs_m_id, f.r_transfer_date2, f.division1, f.division2, f.em_seq,
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 6 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 5 MONTH), tcb.pay_price, 0)) AS '5개월 전', /* -5개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 5 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 4 MONTH), tcb.pay_price, 0)) AS '4개월 전', /* -4개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 4 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 3 MONTH), tcb.pay_price, 0)) AS '3개월 전', /* -3개월 */		
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 3 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 2 MONTH), tcb.pay_price, 0)) AS '2개월 전', /* -2개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 2 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 1 MONTH), tcb.pay_price, 0)) AS '1개월 전', /* -1개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 1 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2), tcb.pay_price, 0)) AS '피이관월', /*피이관월 */	
		 tc.mg_nm AS '업체담당자명', CONCAT(tc.mg_tel1, "-", tc.mg_tel2, "-", tc.mg_tel3) AS '업체담당자유선연락처', CONCAT(tc.mg_cell1, "-", tc.mg_cell2, "-", tc.mg_cell3) AS '업체담당자무선연락처', 
		 tc.mg_email AS '업체담당자이메일', tc.url AS 'URL', tc.cs_type_new1, tc.cs_num
FROM t_contract AS tcb left OUTER JOIN (SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2021-01-01' AND '2021-01-31') AS f ON tcb.m_nm = f.m_nm AND tcb.cs_m_id = f.cs_m_id
     LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq
WHERE tcb.m_nm IN (264, 41, 496, 808) AND tcb.pay_date BETWEEN '2020-07-01' AND '2021-01-31'
      and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id


insert INTO final_1
SELECT tcb.cs_seq, f.m_nm, f.cs_m_id, f.r_transfer_date2, f.division1, f.division2, f.em_seq,
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 6 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 5 MONTH), tcb.pay_price, 0)) AS '5개월 전', /* -5개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 5 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 4 MONTH), tcb.pay_price, 0)) AS '4개월 전', /* -4개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 4 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 3 MONTH), tcb.pay_price, 0)) AS '3개월 전', /* -3개월 */		
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 3 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 2 MONTH), tcb.pay_price, 0)) AS '2개월 전', /* -2개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 2 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2 - INTERVAL 1 MONTH), tcb.pay_price, 0)) AS '1개월 전', /* -1개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(f.r_transfer_date2 - INTERVAL 1 MONTH) + INTERVAL 1 DAY AND LAST_DAY(f.r_transfer_date2), tcb.pay_price, 0)) AS '피이관월', /*피이관월 */	
		 tc.mg_nm AS '업체담당자명', CONCAT(tc.mg_tel1, "-", tc.mg_tel2, "-", tc.mg_tel3) AS '업체담당자유선연락처', CONCAT(tc.mg_cell1, "-", tc.mg_cell2, "-", tc.mg_cell3) AS '업체담당자무선연락처', 
		 tc.mg_email AS '업체담당자이메일', tc.url AS 'URL', tc.cs_type_new1, tc.cs_num
FROM t_contract AS tcb left OUTER JOIN (SELECT * FROM final WHERE r_transfer_date2 BETWEEN '2021-08-01' AND '2021-08-31') AS f ON tcb.m_nm = f.m_nm AND tcb.cs_m_id = f.cs_m_id
     LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq
WHERE tcb.m_nm IN (264, 41, 496, 808) AND tcb.pay_date BETWEEN '2021-02-01' AND '2021-08-31'
      and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id


DROP TABLE final_1

SELECT * 
FROM final_1
WHERE r_transfer_date2 IS NOT null
================================================================================================================================

요청메일제목: RE: "추석 연휴 운영 전략 광고주" 추출 지원해 주시기 바랍니다.
(받은날짜 :2021. 9. 1. (수) 12:44)

전략기획본부 요청(남정현PM)

/*영업일비영업일평균 구하는 쿼리*/

SELECT getcomkrname(a_2.division1) AS '본부', getcomkrname(a_2.division2) AS '팀', getEmkrName(a_2.em_seq) AS '담당자', getCsKrName(tcb.cs_seq) AS '광고주명',
       getcomkrname(tc.cs_type_new1) AS '업종',
       getcomkrname(CASE WHEN (tcb.m_nm='302' AND tcb.good_type2 IN ('820')) THEN '820' /*티몬*/ 
					          WHEN (tcb.m_nm='302' AND tcb.good_type2 IN ('847')) THEN '847' /*위메프*/ 
					          WHEN (tcb.m_nm='302' AND tcb.good_type2 IN ('844')) THEN '844' /*인터파크*/ 
					          WHEN (tcb.m_nm='302' AND tcb.good_type2 IN ('454')) THEN '454' /*크리테오-CPC*/ 
					          WHEN (tcb.m_nm='302' AND tcb.good_type2 IN ('438')) THEN '438' /*타게팅게이츠*/
					          WHEN (tcb.m_nm='302' AND tcb.good_type2 NOT IN ('820','847','844','454','438')) THEN '302' 
					          ELSE tcb.m_nm
					          end) AS '매체명', getcomkrname(tcb.good_type2) AS '상품' , tcb.cs_m_id AS '광고계정', 
					          
		 round(sum(if(td.holiday_yn='2', pay_price, NULL))/b.open) AS '영업일평균',
		 round(sum(if(td.holiday_yn='1', pay_price, NULL))/b.close) AS '비영업일평균',	 
		 
		 SUM(if(td.holiday_yn='2', pay_price, NULL)) AS '영업일매출합계',
		 SUM(if(td.holiday_yn='1', pay_price, null)) AS '비영업일매출합계',
		 
		 b.open AS '영업일수',
	    b.close AS '비영업일수',
				  
		 SUM(if(pay_date BETWEEN '2021-06-01' AND '2021-06-31', pay_price, 0)) AS '6월',
		 SUM(if(pay_date BETWEEN '2021-07-01' AND '2021-07-31', pay_price, 0)) AS '7월',
		 SUM(if(pay_date BETWEEN '2021-08-01' AND '2021-08-29', pay_price, 0)) AS '8월(29일까지)'		  
				  
FROM t_contract tcb LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq LEFT OUTER JOIN t_days AS td ON tcb.pay_date = td.all_day 
     LEFT OUTER JOIN a_2 ON a_2.m_nm = tcb.m_nm AND a_2.cs_m_id = tcb.cs_m_id, b
WHERE tcb.pay_date BETWEEN '2021-06-01' AND '2021-08-29' and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3) AND tc.cs_type_new1 IN (991, 992, 993, 994, 996, 1002, 1005, 1009, 1010, 1016, 1020)
     AND b.m_nm = tcb.m_nm AND b.cs_m_id = tcb.cs_m_id
GROUP BY tcb.m_nm, tcb.good_type2, tcb.cs_m_id

CREATE TEMPORARY TABLE IF NOT EXISTS a
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT tcb.pay_date, tcb.m_nm, tcb.cs_m_id
FROM t_contract tcb LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq 
WHERE tcb.pay_date BETWEEN '2021-06-01' AND '2021-08-29' and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3) AND tc.cs_type_new1 IN (991, 992, 993, 994, 996, 1002, 1005, 1009, 1010, 1016, 1020)
GROUP BY tcb.pay_date, tcb.m_nm, tcb.cs_m_id


SELECT *
FROM a


CREATE TEMPORARY TABLE IF NOT EXISTS b
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT a.m_nm, a.cs_m_id, sum(if(td.holiday_yn='1', 1, 0)) AS 'close', sum(if(td.holiday_yn='2', 1, 0)) AS 'open'
FROM a LEFT OUTER JOIN t_days AS td ON a.pay_date = td.all_day
GROUP BY a.m_nm, a.cs_m_id

SELECT *
FROM b


CREATE TEMPORARY TABLE IF NOT EXISTS a_1
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT tcb.m_nm, tcb.cs_m_id, max(tcb.pay_date) AS 'max_date'
FROM t_contract tcb LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq 
WHERE tcb.pay_date BETWEEN '2021-06-01' AND '2021-08-29' and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3) AND tc.cs_type_new1 IN (991, 992, 993, 994, 996, 1002, 1005, 1009, 1010, 1016, 1020)
GROUP BY tcb.m_nm, tcb.cs_m_id

DROP TABLE a_1

SELECT *
FROM a_1

CREATE TEMPORARY TABLE IF NOT EXISTS a_2
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT tcb.m_nm, tcb.cs_m_id, te.division1, te.division2, tcb.em_seq
FROM t_contract tcb LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq LEFT OUTER JOIN t_employee AS te ON tcb.em_seq = te.em_seq , a_1 
WHERE tcb.pay_date BETWEEN '2021-06-01' AND '2021-08-29' and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3) AND tc.cs_type_new1 IN (991, 992, 993, 994, 996, 1002, 1005, 1009, 1010, 1016, 1020)
      and tcb.m_nm = a_1.m_nm and tcb.cs_m_id = a_1.cs_m_id AND tcb.pay_date = a_1.max_date 
GROUP BY tcb.m_nm, tcb.cs_m_id


SELECT *
FROM a_2

------------------------------------------------------------------------------------------------------------------------------
/*이관 테이블*/
SELECT CONCAT(m_nm, cs_m_id), division1, division2, em_seq, m_nm, cs_m_id, transfer_date2, CONCAT(m_nm, cs_m_id)
FROM t_real_real_transfer_id
WHERE del_date IS NULL AND state = '완료' AND transfer_date2 >= '2018-01-01'

/*피이관 테이블*/
SELECT CONCAT(m_nm, cs_m_id), division1, division2, em_seq, m_nm, cs_m_id, r_transfer_date2
FROM t_real_real_r_transfer_id 
WHERE del_date IS NULL AND state = '완료' AND r_transfer_date2 >= '2018-01-01'
------------------------------------------------------------------------------------------------------------------------------
/*최신 이관일 임시테이블 생성*/
CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_transfer_id
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_transfer_id a,
(select m_nm, cs_m_id, MAX(transfer_date2) AS max_date 
FROM t_real_real_transfer_id
WHERE del_date IS NULL AND state = '완료' AND transfer_date2 >= '2018-01-01'
GROUP BY m_nm, cs_m_id) b 
WHERE a.transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) and a.del_date IS NULL AND a.state = '완료' AND a.transfer_date2 >= '2018-01-01'
GROUP BY a.m_nm, a.cs_m_id

/*최신 피이관일 임시테이블 생성*/
CREATE TEMPORARY TABLE IF NOT EXISTS max_t_real_real_r_transfer_id
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id), a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM t_real_real_r_transfer_id a,
(select m_nm, cs_m_id, MAX(r_transfer_date2) AS max_date 
FROM t_real_real_r_transfer_id 
WHERE del_date IS NULL AND state = '완료' AND r_transfer_date2 >= '2018-01-01'
GROUP BY m_nm, cs_m_id) b 
WHERE a.r_transfer_date2 = b.max_date AND CONCAT(a.m_nm, a.cs_m_id) = CONCAT(b.m_nm, b.cs_m_id) and a.del_date IS NULL AND a.state = '완료' AND a.r_transfer_date2 >= '2018-01-01'
GROUP BY a.m_nm, a.cs_m_id

/*생성확인*/
SELECT *
FROM max_t_real_real_transfer_id

SELECT *
FROM max_t_real_real_r_transfer_id

------------------------------------------------------------------------------------------------------------------------------
/*최종 피이관 계정 추출*/
CREATE TEMPORARY TABLE IF NOT EXISTS r_transfer
( 
INDEX `m_nm` (m_nm),
INDEX `cs_m_id` (cs_m_id)
)
SELECT CONCAT(a.m_nm, a.cs_m_id) AS 'key', a.m_nm, a.cs_m_id, a.r_transfer_date2, a.division1, a.division2, a.em_seq
FROM max_t_real_real_r_transfer_id a LEFT OUTER JOIN max_t_real_real_transfer_id b ON a.m_nm = b.m_nm AND a.cs_m_id = b.cs_m_id
WHERE a.r_transfer_date2 > b.transfer_date2 OR b.transfer_date2 IS null

/*생성확인*/
SELECT *
FROM r_transfer

------------------------------------------------------------------------------------------------------------------------------








=======================================================================================================
@1부문 이은주 피엠님 퇴사자 전후 6개월 매출 추이

SELECT getcomkrname(CASE
						  WHEN (m_nm='302' AND good_type2 IN ('820')) THEN '820' /*티몬*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('847')) THEN '847' /*위메프*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('844')) THEN '844' /*인터파크*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('454')) THEN '454' /*크리테오-CPC*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('438')) THEN '438' /*타게팅게이츠*/
						  WHEN (m_nm='302' AND good_type2 NOT IN ('820','847','844','454','438')) THEN '302' 
						  ELSE m_nm
						  end) AS '매체명', cs_m_id AS '광고계정',
	SUM(if(pay_date BETWEEN '2021-06-01' AND '2021-06-31', pay_price, 0)) AS '6월',
	SUM(if(pay_date BETWEEN '2021-07-01' AND '2021-07-31', pay_price, 0)) AS '7월',
	SUM(if(pay_date BETWEEN '2021-08-01' AND '2021-08-31', pay_price, 0)) AS '8월',
   SUM(if(pay_date BETWEEN '2021-09-01' AND '2021-09-31', pay_price, 0)) AS '9월'
	
FROM t_contract
WHERE pay_date BETWEEN '2021-06-01' AND '2021-09-31' and del_date is NULL AND sales_type=1 and agree_state IN (2, 3)
GROUP BY m_nm, cs_m_id



----------------------------
CREATE TEMPORARY TABLE IF NOT EXISTS a
( 
INDEX `m_nm` (매체명),
INDEX `cs_m_id` (광고계정)
)
SELECT getEmkrName(tcb.em_seq) AS '직원명', getcomkrname(te.division1) AS '본부', getcomkrname(te.division2) AS '팀', CONCAT(cast(TIMESTAMPDIFF(MONTH, te.join_date, te.end_date) AS char), '개월') AS '재직기간' ,te.join_date AS '입사일', te.end_date AS '퇴사일', 
		 YEAR(te.end_date) AS '퇴사년도', CONCAT('2021-',(MONTH(te.end_date)-1)) AS '퇴사전월', MONTH(te.end_date) AS '퇴사월', 
		 getcomkrname(CASE
						  WHEN (m_nm='302' AND good_type2 IN ('820')) THEN '820' /*티몬*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('847')) THEN '847' /*위메프*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('844')) THEN '844' /*인터파크*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('454')) THEN '454' /*크리테오-CPC*/ 
						  WHEN (m_nm='302' AND good_type2 IN ('438')) THEN '438' /*타게팅게이츠*/
						  WHEN (m_nm='302' AND good_type2 NOT IN ('820','847','844','454','438')) THEN '302' 
						  ELSE m_nm
						  end) AS '매체명', tcb.cs_m_id AS '광고계정', getCsKrName(tcb.cs_seq) AS '광고주명', 		 
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 7 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 6 MONTH), tcb.pay_price, 0)) AS '6개월 전', /* -6개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 6 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 5 MONTH), tcb.pay_price, 0)) AS '5개월 전', /* -5개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 5 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 4 MONTH), tcb.pay_price, 0)) AS '4개월 전', /* -4개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 4 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 3 MONTH), tcb.pay_price, 0)) AS '3개월 전', /* -3개월 */		
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 3 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 2 MONTH), tcb.pay_price, 0)) AS '2개월 전', /* -2개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 2 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 1 MONTH), tcb.pay_price, 0)) AS '1개월 전', /* -1개월 */ 
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 1 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date), tcb.pay_price, 0)) AS '퇴사월 매출' /* 퇴사월 */	
FROM t_contract AS tcb LEFT OUTER JOIN (SELECT em_seq, end_date, join_date, division1, division2 FROM t_employee) AS te ON tcb.em_seq = te.em_seq
WHERE (te.end_date >= '2021-06-01') and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id, te.em_seq;

DROP TABLE a
SELECT *
FROM a



=======================================================================================================
@성과 이슈 광고주 구하는 쿼리

SELECT a.cs_seq, SUM(a.cost), SUM(c.cs_seq)
FROM t_report_daily AS a LEFT OUTER JOIN (SELECT cs_seq, sum(cost) FROM t_report_daily WHERE pay_date = '2021-07-26'group by cs_seq) AS c ON a.cs_seq = c.cs_seq
WHERE a.pay_date = '2021-07-19'
group BY a.cs_seq

SELECT COUNT(b)
from(SELECT a.cs_seq, IF((SUM(c.cs_seq)-SUM(a.cost))/SUM(a.cost)*100<=-10, 1, NULL) AS b
FROM t_report_daily AS a LEFT OUTER JOIN (SELECT cs_seq, sum(cost) FROM t_report_daily WHERE pay_date = '2021-07-26'group by cs_seq) AS c ON a.cs_seq = c.cs_seq
WHERE a.pay_date = '2021-07-19'
group BY a.cs_seq) d

SELECT a.cs_seq, IF((SUM(c.cs_seq)-SUM(a.cost))/SUM(a.cost)*100<=-10, 1, NULL) AS b
FROM t_report_daily AS a LEFT OUTER JOIN (SELECT cs_seq, sum(cost) FROM t_report_daily WHERE pay_date = '2021-07-26'group by cs_seq) AS c ON a.cs_seq = c.cs_seq
WHERE a.pay_date = '2021-07-19'
group BY a.cs_seq

=======================================================================================================
@RMS에 있는데 AMS에는 없는 계정 구하는 쿼리

/*RMS*/
SELECT getcomkrname(division1), getEmkrName(em_seq), getCsKrName(cs_seq), getcomkrname(m_nm), cs_m_id, SUM(pay_price)
FROM t_contract 
WHERE del_date IS NULL AND sales_type IN ('1') AND agree_state IN ('3') AND pay_date = '2021-07-22' AND m_nm IN (881, 41, 264)
GROUP BY m_nm, cs_m_id

/*AMS*/
SELECT getMediaName(media_code), matching_id, SUM(cost)
FROM t_report_daily
WHERE pay_date = '2021-07-22' AND media_code IN (5, 6, 7, 89)
GROUP BY media_code, matching_id

=======================================================================================================
@인입 이탈 월별 추이 쿼리

-퇴사자가 담당했던 계정 뽑는 쿼리(계정 중복)
SELECT getcomkrname(tcb.m_nm) AS '매체명', tcb.cs_m_id AS '광고계정', 

		 tc.cs_nm AS '광고주명', tc.url AS 'URL', CONCAT(tc.tel1, "-", tc.tel2, "-", tc.tel3) AS '대표전화번호', CONCAT(tc.cell1, "-", tc.cell2, "-", tc.cell3) AS '대표핸드폰번호',

		 tc.mg_nm AS '업체담당자명', CONCAT(tc.mg_tel1, "-", tc.mg_tel2, "-", tc.mg_tel3) AS '업체담당자전화번호', CONCAT(tc.mg_cell1, "-", tc.mg_cell2, "-", tc.mg_cell3) AS '업체담당자핸드폰번호', 
		 tc.mg_email AS '업체담당자이메일', 

		 getcomkrname(te.division1) AS '본부', getcomkrname(te.division2) AS '팀', getEmkrName(tcb.em_seq) AS '직원명', te.end_date AS '퇴사일',
		 
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 4 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 3 MONTH), tcb.pay_price, 0)) AS '3개월 전', /* -3개월 */		
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 3 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 2 MONTH), tcb.pay_price, 0)) AS '2개월 전', /* -2개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 2 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 1 MONTH), tcb.pay_price, 0)) AS '1개월 전', /* -1개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 1 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date), tcb.pay_price, 0)) AS '퇴사월' /* 퇴사월 */
		 		 
FROM t_contract AS tcb LEFT OUTER JOIN (SELECT em_seq, end_date, division1, division2 FROM t_employee) AS te ON tcb.em_seq = te.em_seq LEFT OUTER JOIN t_customer AS tc ON tcb.cs_seq = tc.cs_seq
WHERE tcb.m_nm IN (264/*네이버*/, 41/*카카오*/, 496/*이베이*/, 808/*11번가*/) AND (te.end_date BETWEEN '2019-01-01' AND '2019-06-31') and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id, tcb.em_seq;

--------------------------------------------------------------------------------------

-최신 퇴사자 뽑는 쿼리

-담당자별 맥스 페이 데이트
SELECT tcb.m_nm, tcb.cs_m_id, tcb.em_seq, MAX(tcb.pay_date)
FROM t_contract AS tcb LEFT OUTER JOIN (SELECT em_seq, end_date, division1, division2 FROM t_employee) AS te ON tcb.em_seq = te.em_seq
WHERE tcb.m_nm IN (264/*네이버*/, 41/*카카오*/, 496/*이베이*/, 808/*11번가*/) AND (te.end_date BETWEEN '2019-01-01' AND '2021-12-31') and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id, tcb.em_seq

-광고 계정별 맥스 페이 데이트
SELECT tcb.m_nm, tcb.cs_m_id, MAX(tcb.pay_date)
FROM t_contract AS tcb LEFT OUTER JOIN (SELECT em_seq, end_date, division1, division2 FROM t_employee) AS te ON tcb.em_seq = te.em_seq
WHERE tcb.m_nm IN (264/*네이버*/, 41/*카카오*/, 496/*이베이*/, 808/*11번가*/) AND (te.end_date BETWEEN '2019-01-01' AND '2021-12-31') and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id

--------------------------------------------------------------------------------------

-역대 HM 담당자 뽑는 쿼리
SELECT m_nm, cs_m_id, GROUP_CONCAT(DISTINCT getEmkrName(em_seq) order by pay_date desc)
FROM t_contract
WHERE m_nm IN (264, 41, 496, 808) AND del_date is NULL AND sales_type=1 and agree_state IN (2, 3) AND pay_date <'2013-01-01'
GROUP BY m_nm, cs_m_id

--------------------------------------------------------------------------------------

@이관테이블
SELECT *
FROM t_real_real_transfer_id
WHERE del_date IS NULL

SELECT m_nm, min(transfer_date2)
FROM t_real_real_transfer_id
WHERE del_date IS NULL
GROUP BY m_nm

--------------------------------------------------------------------------------------

@피이관테이블
SELECT *
FROM t_real_real_r_transfer_id
WHERE del_date IS NULL

SELECT m_nm, min(r_transfer_date2)
FROM t_real_real_r_transfer_id
WHERE del_date IS NULL
GROUP BY m_nm

=======================================================================================================
@인입 이탈 월별 추이 쿼리

/*뽑는쿼리*/
SELECT getComKrName(te.division1), getComKrName(te.division2), getEmkrName(tamh.em_seq), tamm.cs_seq, tamm.advertiser_name,
		 COUNT(if(tamh.start_date <= '2021-01-31' AND (tamh.end_date >= '2021-01-31' OR tamh.end_date IS NULL) AND STATUS IN (1, 3, 4, 7), 1, null)) AS '2021-01 인입',	 	 	 
		 COUNT(if(tamh.start_date <= '2021-02-28'AND (tamh.end_date >= '2021-02-28' OR tamh.end_date IS NULL) AND STATUS IN (1, 3, 4, 7), 1, null)) AS '2021-02 인입',
		 COUNT(if(tamh.start_date <= '2021-03-31'AND (tamh.end_date >= '2021-03-31' OR tamh.end_date IS NULL) AND STATUS IN (1, 3, 4, 7), 1, null)) AS '2021-03 인입',
		 COUNT(if(tamh.start_date <= '2021-04-30'AND (tamh.end_date >= '2021-04-30' OR tamh.end_date IS NULL) AND STATUS IN (1, 3, 4, 7), 1, null)) AS '2021-04 인입',
		 COUNT(if(tamh.start_date <= '2021-05-31'AND (tamh.end_date >= '2021-05-31' OR tamh.end_date IS NULL) AND STATUS IN (1, 3, 4, 7), 1, null)) AS '2021-05 인입',
		 COUNT(if(tamh.start_date <= '2021-01-31'AND (tamh.end_date >= '2021-01-31' OR tamh.end_date IS NULL) AND STATUS not IN (1, 3, 4, 7), 1, null)) AS '2021-01 이탈',
		 COUNT(if(tamh.start_date <= '2021-02-28'AND (tamh.end_date >= '2021-02-28' OR tamh.end_date IS NULL) AND STATUS not IN (1, 3, 4, 7), 1, null)) AS '2021-02 이탈',
		 COUNT(if(tamh.start_date <= '2021-03-31'AND (tamh.end_date >= '2021-03-31' OR tamh.end_date IS NULL) AND STATUS not IN (1, 3, 4, 7), 1, null)) AS '2021-03 이탈',
		 COUNT(if(tamh.start_date <= '2021-04-30'AND (tamh.end_date >= '2021-04-30' OR tamh.end_date IS NULL) AND STATUS not IN (1, 3, 4, 7), 1, null)) AS '2021-04 이탈',
		 COUNT(if(tamh.start_date <= '2021-05-31'AND (tamh.end_date >= '2021-05-31' OR tamh.end_date IS NULL) AND STATUS not IN (1, 3, 4, 7), 1, null)) AS '2021-05 이탈' 
FROM t_advertiser_media_history AS tamh LEFT OUTER JOIN t_advertiser_media_management AS tamm ON tamh.advertiser_id = tamm.increment_id
LEFT OUTER JOIN t_employee AS te ON tamh.em_seq = te.em_seq
GROUP BY tamh.em_seq, tamm.cs_seq

/*검증하는쿼리*/
SELECT *
FROM t_advertiser_media_history AS tamh LEFT OUTER JOIN t_advertiser_media_management AS tamm ON tamh.advertiser_id = tamm.increment_id
LEFT OUTER JOIN t_employee AS te ON tamh.em_seq = te.em_seq
WHERE tamm.cs_seq = '63629' AND STATUS IN (2, 5, 6)



=======================================================================================================
@대시보드 데이터 확인
-총광고비
SELECT sum(cost)
FROM t_report_daily
WHERE pay_date='2021-05-14' AND em_seq != 'none'

-노출계정수
SELECT media_code, matching_id
FROM t_report_daily
WHERE pay_date='2021-05-14' AND impression_cnt > 0
GROUP BY media_code, matching_id


=======================================================================================================
@이사님 GFA분석하라고 하실 때 사용한 쿼리

SELECT pay_date, hm.getEmkrName(em_seq), hm.getComKrName(division), hm.getComKrName(team), cs_seq, cs_nm, hm.getComKrName(cs_type_new1), matching_id, product_type,
       impression_cnt, click_cnt, cost, conversion_cnt, conversion_amnt
FROM t_report_daily
WHERE pay_date BETWEEN '2021-04-01' AND '2021-04-30' AND product_type IN ('모바일 메인', '모바일 서브_배너', '모바일 서브_피드', '밴드 피드', '스마트채널')

=======================================================================================================
@최신담당자 추출할 때 사용 했던 쿼리
SELECT getCsKrName(tco.cs_seq) AS 광고주명, tcu.cs_num AS 사업자번호, tcu.url AS URL, getcomkrname(IF(tco.m_nm='302',tco.good_type2, tco.m_nm)) AS 매체, tco.cs_m_id AS 광고계정, SUM(tco.pay_price) AS 매출, 
getcomkrname(tco.division1) AS 부서 , getcomkrname(tco.division2) AS 팀, getEmkrName(tco.em_seq) AS 담당자
FROM t_contract AS tco LEFT OUTER JOIN t_customer AS tcu ON tco.cs_seq = tcu.cs_seq 
WHERE tco.del_date is NULL AND tco.sales_type=1 and tco.agree_state IN (2, 3) AND tco.pay_date >= '2021-03-01' 
GROUP BY tco.cs_seq, 매체, tco.cs_m_id

=======================================================================================================

@ams이용 현황
SELECT DATE_FORMAT(`ac_date`, '%Y-%m-%d') AS DAY, ac_em_id
FROM t_access_log
WHERE ac_reason = '3'
GROUP BY DAY, ac_em_id
ORDER BY DAY

@ams 잔액조회 이용 현황
SELECT reg_date, division, COUNT(DISTINCT reg_emp)
FROM t_bizmoney_log
GROUP BY reg_date, division
ORDER BY reg_date

=======================================================================================================
@매체별 광고비, 광고주수 도출하는 쿼리

@각매체썸확인하는쿼리
SELECT SUM(cost)
FROM t_report_daily
where pay_date = '2021-04-01' and media_code = '5' AND em_seq != 'none' and product_type IN ('3')

@각매체광고주수구하는쿼리
SELECT count(DISTINCT cs_seq)
FROM t_report_daily
where pay_date = '2021-04-01' and media_code = '5' AND em_seq != 'none' AND cost != 0

@각매체 일자별썸확인하는쿼리
SELECT SUM(cost)
FROM t_report_daily
where pay_date IN('2021-04-14') and media_code = '5' AND em_seq != 'none' and em_seq = '566'

@각매체 일자별광고주수구하는쿼리
SELECT count(DISTINCT cs_seq)
FROM t_report_daily
where pay_date = '2021-03-30' and media_code = '5' AND em_seq != 'none' AND cost != 0 and product_type IN ('0', '6', '1')

@각매체 월별별썸확인하는쿼리
SELECT SUM(cost)
FROM t_report_month
where pay_date IN('2020-12') and media_code = '5' AND em_seq != 'none' 

@각매체 월별광고주수구하는쿼리
SELECT count(DISTINCT cs_seq)
FROM t_report_month
where pay_date = '2020-12' and media_code = '5' AND em_seq != 'none' AND cost != 0


=======================================================================================================
@매체별, 신규.기존 계정 데이터 도출하는 쿼리

CREATE TEMPORARY TABLE IF NOT EXISTS tb_real_csmid1_2
( 
INDEX `m_nm1` (m_nm1),
INDEX `cs_m_id` (cs_m_id)
)
SELECT * FROM (
SELECT cs_seq, m_nm, cs_m_id, MIN(pay_date) AS pay_date, 
CASE 
WHEN (m_nm='302' && good_type2 IN ('820')) THEN '820' /*티몬*/
WHEN (m_nm='302' && good_type2 IN ('847')) THEN '847' /*위메프*/
WHEN (m_nm='302' && good_type2 IN ('844')) THEN '844' /*인터파크*/
WHEN (m_nm='302' && good_type2 IN ('454')) THEN '454' /*크리테오-CPC*/
WHEN (m_nm='302' && good_type2 IN ('438')) THEN '438' /*타게팅게이츠*/
WHEN (m_nm='302' AND good_type2 NOT IN ('820','847','844','454','438')) THEN 'etc' 
ELSE m_nm
END AS m_nm1
FROM t_contract 
WHERE del_date IS NULL 
AND sales_type IN ('1') 
AND agree_state IN ('3') 
AND pay_date < '2021-04-01'
GROUP BY m_nm, cs_m_id, good_type2
) AS a
WHERE m_nm1 NOT IN ('etc')
GROUP BY m_nm1, cs_m_id;


CREATE TEMPORARY TABLE IF NOT EXISTS tb_real_csmid2_2
( 
INDEX `m_nm1` (m_nm1),
INDEX `cs_m_id` (cs_m_id)
)
SELECT * FROM (
SELECT cs_seq, m_nm, cs_m_id, MAX(pay_date) AS pay_date1, MIN(pay_date) AS pay_date2, SUM(pay_price) AS pay_price, 
CASE
WHEN (m_nm='302' AND good_type2 IN ('820')) THEN '820' /*티몬*/ 
WHEN (m_nm='302' AND good_type2 IN ('847')) THEN '847' /*위메프*/ 
WHEN (m_nm='302' AND good_type2 IN ('844')) THEN '844' /*인터파크*/ 
WHEN (m_nm='302' AND good_type2 IN ('454')) THEN '454' /*크리테오-CPC*/ 
WHEN (m_nm='302' AND good_type2 IN ('438')) THEN '438' /*타게팅게이츠*/
WHEN (m_nm='302' AND good_type2 NOT IN ('820','847','844','454','438')) THEN 'etc' 
ELSE m_nm
END AS m_nm1
FROM t_contract 
WHERE del_date IS NULL 
AND sales_type IN ('1') 
AND agree_state IN ('3') 
AND pay_date BETWEEN '2021-04-01' AND '2021-04-31'
GROUP BY m_nm, cs_m_id, good_type2
) AS a
WHERE m_nm1 NOT IN ('etc')
GROUP BY m_nm1, cs_m_id;


SELECT getcomkrname(a.m_nm1) AS '매체명', a.m_nm1, a.cs_m_id AS '광고계정', a.pay_date1 AS '마지막소진일자', a.pay_date2 AS '기간내최초소진일자', b.pay_date AS '최초소진일자',  IF(b.m_nm1 IS NULL, '신규', '기존')  AS '구분', pay_price AS '소진액'
/*into m_nm, cs_m_id, pay_date, csmid_type*/ 
FROM tb_real_csmid2_2 AS a LEFT OUTER JOIN tb_real_csmid1_2 AS b
ON a.m_nm1=b.m_nm1
AND a.cs_m_id=b.cs_m_id



=======================================================================================================
@AMS 요청, 관리 이용 현황 파악용 쿼리


/*부문별*/
/*
SELECT ifnull(hm.getComKrName(division),'-') AS '부문',  COUNT(if(result IN (1, 2),result,NULL)) AS '요청(완료+미처리)', COUNT(if(result=1,result,NULL)) AS '완료', COUNT(if(result=2,result,NULL)) AS '미처리', COUNT(if(result=3,result,NULL)) AS '관리', COUNT(result) AS '전체건수(요청+관리)'
FROM t_job_management
GROUP BY division
ORDER BY division
*/
/*개인*/

SELECT ifnull(hm.getComKrName(division),'-') AS '부문', ifnull(hm.getComKrName(team), '-') AS '팀', ifnull(em_seq_kr, '-') AS '담당자명',  COUNT(if(result IN (1, 2),result,NULL)) AS '요청(완료+미처리)', COUNT(if(result=1,result,NULL)) AS '완료', COUNT(if(result=2,result,NULL)) AS '미처리', COUNT(if(result=3,result,NULL)) AS '관리', COUNT(result) AS '전체건수(요청+관리)'
FROM t_job_management
GROUP BY em_seq_kr
ORDER BY division



=======================================================================================================
@퇴사월 전후 6개월 매출 추이 구하는 쿼리


SELECT getcomkrname(m_nm) AS '매체명', cs_m_id AS '광고계정', 

	SUM(if(pay_date BETWEEN '2020-01-01' AND '2020-01-31', pay_price, 0)) AS '1월',
	SUM(if(pay_date BETWEEN '2020-02-01' AND '2020-02-31', pay_price, 0)) AS '2월',
	SUM(if(pay_date BETWEEN '2020-03-01' AND '2020-03-31', pay_price, 0)) AS '3월',
	SUM(if(pay_date BETWEEN '2020-04-01' AND '2020-04-31', pay_price, 0)) AS '4월',
	SUM(if(pay_date BETWEEN '2020-05-01' AND '2020-05-31', pay_price, 0)) AS '5월',
	SUM(if(pay_date BETWEEN '2020-06-01' AND '2020-06-31', pay_price, 0)) AS '6월',
	
	SUM(if(pay_date BETWEEN '2020-07-01' AND '2020-07-31', pay_price, 0)) AS '7월',
	SUM(if(pay_date BETWEEN '2020-08-01' AND '2020-08-31', pay_price, 0)) AS '8월',
	SUM(if(pay_date BETWEEN '2020-09-01' AND '2020-09-31', pay_price, 0)) AS '9월',
	SUM(if(pay_date BETWEEN '2020-10-01' AND '2020-10-31', pay_price, 0)) AS '10월',
	SUM(if(pay_date BETWEEN '2020-11-01' AND '2020-11-31', pay_price, 0)) AS '11월',
	SUM(if(pay_date BETWEEN '2020-12-01' AND '2020-12-31', pay_price, 0)) AS '12월',
	SUM(if(pay_date BETWEEN '2021-01-01' AND '2021-01-31', pay_price, 0)) AS '01월'
	
FROM t_contract
WHERE pay_date BETWEEN '2020-01-01' AND '2021-01-31' AND m_nm IN (264, 41, 496, 808) and del_date is NULL AND sales_type=1 and agree_state IN (2, 3) AND cs_m_id = 'uj15519'
GROUP BY m_nm, cs_m_id



----------------------------

SELECT getcomkrname(tcb.m_nm) AS '매체명', tcb.cs_m_id AS '광고계정', te.end_date AS '퇴사일', getcomkrname(te.division1) AS '본부', getcomkrname(te.division2) AS '팀', getEmkrName(tcb.em_seq) AS '직원명',
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 7 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 6 MONTH), tcb.pay_price, 0)) AS '6개월 전', /* -6개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 6 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 5 MONTH), tcb.pay_price, 0)) AS '5개월 전', /* -5개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 5 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 4 MONTH), tcb.pay_price, 0)) AS '4개월 전', /* -4개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 4 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 3 MONTH), tcb.pay_price, 0)) AS '3개월 전', /* -3개월 */		
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 3 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 2 MONTH), tcb.pay_price, 0)) AS '2개월 전', /* -2개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 2 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date - INTERVAL 1 MONTH), tcb.pay_price, 0)) AS '1개월 전', /* -1개월 */
		 SUM(if(tcb.pay_date BETWEEN LAST_DAY(te.end_date - INTERVAL 1 MONTH) + INTERVAL 1 DAY AND LAST_DAY(te.end_date), tcb.pay_price, 0)) AS '퇴사월' /* 퇴사월 */		 
FROM t_contract AS tcb LEFT OUTER JOIN (SELECT em_seq, end_date, division1, division2 FROM t_employee) AS te ON tcb.em_seq = te.em_seq 
WHERE tcb.m_nm IN (264, 41, 496, 808) AND (te.end_date BETWEEN '2020-06-01' AND '2021-01-31') and tcb.del_date is NULL AND tcb.sales_type=1 and tcb.agree_state IN (2, 3)
GROUP BY tcb.m_nm, tcb.cs_m_id, te.em_seq;


=======================================================================================================
@AMS노출계정수
SELECT trd.media_code, tmc.product_kr_name ,COUNT(DISTINCT(trd.matching_id))
FROM t_report_daily AS trd
LEFT JOIN t_media_common AS tmc
ON tmc.increment_id = trd.media_code
WHERE trd.pay_date = '2020-11-22' AND trd.impression_cnt > 0 AND trd.cs_nm != 'None' 
GROUP BY trd.media_code
ORDER BY COUNT(DISTINCT(trd.matching_id)) DESC
=======================================================================================================
@AMS총계정수
SELECT `media_code`, 
       total_account                               AS target, 
       (1_account+2_account+3_account+4_account)/4 AS compare 
FROM   ( 
                SELECT   target.media_code, 
                         count(DISTINCT matching_id)                                           AS total_account,
                         count(DISTINCT IF(advertiser_start <= '2020-11-15',matching_id,NULL)) AS 1_account, 
                         count(DISTINCT IF(advertiser_start <= '2020-11-08',matching_id,NULL)) AS 2_account, 
                         count(DISTINCT IF(advertiser_start <= '2020-11-01',matching_id,NULL)) AS 3_account, 
                         count(DISTINCT IF(advertiser_start <= '2020-10-25',matching_id,NULL)) AS 4_account 
                FROM     ( 
                                  SELECT   tamh.*, 
                                           min(tamh.start_date) AS advertiser_start 
                                  FROM     ( 
                                                    SELECT   * 
                                                    FROM     `t_advertiser_media_history` 
                                                    WHERE    start_date <= '2020-11-22' 
                                                    ORDER BY `start_date` DESC, 
                                                             `increment_id` DESC limit 100000000000000) AS tamh
                                  GROUP BY `media_code`, 
                                           `matching_id`) AS target 
                WHERE    status != 2 
                GROUP BY `media_code`) AS main
=======================================================================================================
@AMS월별 광고성과
SELECT getComKrName(division) AS '부문', cs_nm AS '광고주명', IFNULL(getComKrName(cs_type_new1), '-') AS '신규 업종 1차 카테고리', getEmkrName(em_seq) AS '담당자명', if(getMediaName(media_code) = '네이버', '네이버-쇼검', getMediaName(media_code)) AS '매체구분', matching_id AS '광고계정',
		SUM(impression_cnt) AS '노출수', SUM(click_cnt) AS '클릭수', SUM(cost) AS '광고비', SUM(conversion_cnt) AS '전환수', SUM(conversion_amnt) AS '전환금액', IFNULL(concat(round(SUM(conversion_amnt)/SUM(cost)*100,1),'%'), 0) AS 'ROAS', DATE_FORMAT(`pay_date`, '%Y-%m') AS `기간`
FROM t_report_daily
WHERE pay_date BETWEEN '2020-12-01' AND '2020-12-31' AND (media_code IN (9,13) or product_type='2')
GROUP BY media_code, matching_id, division
=======================================================================================================
@AMS월별 추이
SELECT getComKrName(if(trd1.division!=les.division, les.division, trd1.division)) AS '부문', trd1.cs_nm AS '광고주명', IFNULL(getComKrName(trd1.cs_type_new1), '-') AS '신규 업종 1차 카테고리', getEmkrName(if(trd1.em_seq!=les.em_seq, les.em_seq, trd1.em_seq)) AS '담당자명', if(getMediaName(trd1.media_code) = '네이버', '네이버-쇼검', getMediaName(trd1.media_code))  AS '매체구분', trd1.matching_id AS '광고계정',
		trd1.노출수 AS '노출수(2020-11)', trd1.클릭수 AS '클릭수(2020-11)', trd1.전환수 AS '전환수(2020-11)', trd1.전환금액 AS '전환금액(2020-11)', trd1.광고비 AS '광고비(2020-11)', IFNULL(trd2.광고비, 0) AS '광고비(2020-10)', IFNULL(trd3.광고비, 0) AS '광고비(2020-09)', IFNULL(trd4.광고비, 0) AS '광고비(2020-08)', trd1.ROAS AS 'ROAS(2020-11)', IFNULL(trd2.ROAS, '-') AS 'ROAS(2020-10)', IFNULL(trd3.ROAS, '-') AS 'ROAS(2020-09)', IFNULL(trd4.ROAS, '-') AS 'ROAS(2020-08)' 
FROM (SELECT division, cs_nm, cs_type_new1, em_seq, media_code, matching_id, SUM(impression_cnt) AS '노출수', SUM(click_cnt) AS '클릭수', SUM(cost) AS '광고비', SUM(conversion_cnt) AS '전환수', SUM(conversion_amnt) AS '전환금액', IFNULL(concat(round(SUM(conversion_amnt)/SUM(cost)*100,1),'%'), '-') AS 'ROAS' /*해당월  광고 성과*/
		FROM t_report_daily 
		WHERE pay_date BETWEEN '2020-11-01' AND '2020-11-30' AND (media_code IN (9,13) or product_type='2')
		GROUP BY media_code, matching_id
		) AS trd1 
		LEFT OUTER JOIN ( /*1달 전 광고비, ROAS*/
		SELECT media_code, matching_id, SUM(cost) AS '광고비', IFNULL(concat(round(SUM(conversion_amnt)/SUM(cost)*100,1),'%'), 0) AS 'ROAS'
		FROM t_report_daily
		WHERE pay_date BETWEEN '2020-10-01' AND '2020-10-31' AND (media_code IN (9,13) or product_type='2')
		GROUP BY media_code, matching_id
		) AS trd2 ON trd1.media_code=trd2.media_code AND trd1.matching_id=trd2.matching_id
		LEFT OUTER JOIN ( /*2달 전 광고비, ROAS*/
		SELECT media_code, matching_id, SUM(cost) AS '광고비', IFNULL(concat(round(SUM(conversion_amnt)/SUM(cost)*100,1),'%'), 0) AS 'ROAS'
		FROM t_report_daily
		WHERE pay_date BETWEEN '2020-09-01' AND '2020-09-30' AND (media_code IN (9,13) or product_type='2')
		GROUP BY media_code, matching_id
		) AS trd3 ON trd1.media_code=trd3.media_code AND trd1.matching_id=trd3.matching_id
		LEFT OUTER JOIN ( /*3달 전 광고비, ROAS*/
		SELECT media_code, matching_id, SUM(cost) AS '광고비', IFNULL(concat(round(SUM(conversion_amnt)/SUM(cost)*100,1),'%'), 0) AS 'ROAS'
		FROM t_report_daily
		WHERE pay_date BETWEEN '2020-08-01' AND '2020-08-31' AND (media_code IN (9,13) or product_type='2')
		GROUP BY media_code, matching_id
		) AS trd4 ON trd1.media_code=trd4.media_code AND trd1.matching_id=trd4.matching_id
		LEFT OUTER JOIN (	/*최신 담당자 기준*/
		SELECT division, em_seq, media_code, matching_id 
		FROM t_report_daily
		WHERE pay_date IN (SELECT MAX(pay_date) FROM t_report_daily WHERE pay_date BETWEEN '2020-08-01' AND '2020-11-30'  AND (media_code IN (9,13) or product_type='2'))
		AND pay_date BETWEEN '2020-08-01' AND '2020-11-30' AND (media_code IN (9,13) or product_type='2')
		) AS les ON trd1.media_code=les.media_code AND trd1.matching_id=les.matching_id;
=======================================================================================================



@RMS 매체별 광고비 총썸 쿼리
SELECT pay_date, 
	SUM(CASE WHEN m_nm='41' OR good_type2='957' THEN pay_price ELSE 0 END) AS '카카오',  /*rms 카카오+k-쇼핑박스*/
	SUM(CASE WHEN m_nm='496' THEN pay_price ELSE 0 END) AS '이베이',
	SUM(CASE WHEN m_nm='265' THEN pay_price ELSE 0 END) AS '구글',
	SUM(CASE WHEN m_nm='264' THEN pay_price ELSE 0 END) AS '네이버', /*rms 네이버+파워컨텐츠*/
	SUM(CASE WHEN m_nm='845' THEN pay_price ELSE 0 END) AS '페이스북',
	SUM(CASE WHEN good_type2='438' THEN pay_price ELSE 0 END) AS 'TG',
	SUM(CASE WHEN m_nm='808' THEN pay_price ELSE 0 END) AS '11st',
	SUM(CASE WHEN good_type2='847'OR good_type2='984' OR good_type2 ='985' THEN pay_price ELSE 0 END) AS '위메프',
	SUM(CASE WHEN good_type2='820' THEN pay_price ELSE 0 END) AS '티몬',
	SUM(CASE WHEN good_type2 IN('885','893') THEN pay_price ELSE 0 END) AS '신세계',
	SUM(CASE WHEN good_type2 IN('844') THEN pay_price ELSE 0 END) AS '인터파크',
	SUM(CASE WHEN good_type2 IN('974') THEN pay_price ELSE 0 END) AS '롯데온'
FROM t_contract 
WHERE del_date IS NULL 
AND (m_nm IN (41,496,265,264,845,808) OR good_type2 IN (438,957,847,984,985,820,885,893,844,974) )
AND sales_type='1'
AND agree_state='3'
AND pay_date BETWEEN '2020-10-01' AND '2020-11-06' 
GROUP BY pay_date;










아래의 쿼리는 학부 시절 스터디 할 때 사용했던 쿼리입니다.(업무와 무관)
==========================================================================================================================









3/9
@@문제5. 사원 테이블에 직업의 종류가 무엇이 있는지 조회하시오!

*distinct ~> 중복제거하는 키워드
select distinct job
from emp;

@@문제6. 부서번호의 사원테이블에 무엇이 있는지 조회하시오!
*select distinct deptno
from emp;

@@문제7. 사원번호가 7788 번인 사원의 사원번호와 이름을 출력하시오!

select empno, ename
from emp
where empno = 7788 ; --검색조건

@@문제8. 월급 3000 인 사원들의 이름과 월급을 출력하시오!
select ename, sal
from emp
where sal = 3000 ;

@@문제9. 직업이 salesman 인 사원들의 이름과 월급과 직업을 출력하시오!
select ename, sal, job
from emp
where job = 'SALESMAN' ;    <-안에 대문자를 사용해야 한다....

@문자는 양쪽에 싱글 쿼테이션 마크를 사용해야한다 싱글 쿼테이션 마크안에 있는건 문자다라고 오라클에게 알려준다

@문자와 날짜는 양쪽에 싱글쿼테이션 마크를 사용해야하고 숫자는 사용할 필요 없다.

@연산자의 종류 3가지
1.산술연산자 : 곱하기 나누기 더하기 빼기
2.비교 연산자: >,<,>=,<=,=,<>,!=,^=
3.논리연산자: and , or, not

@@문제10. 월급이 3000이상인 사원들의 이름과 월급을 출력하시오!
select ename, sal
from emp
where sal >=3000 ;

@@문제11. 직업이 SALESMAN이 아닌 사원들의 이름과 직업을 출력하시오
select ename , job
from emp
where job != 'SALESMAN' ;

@@문제12. 81년 4월 1일에 입사한 사원들의 이름과 입사일을 출력하시오!
select ename, hiredate 
from emp
where hiredate = '81/04/01';   <- 문자와 날짜는 양쪽에 싱글쿼테이션 마크를 사용해야 한다는거!!!!!!

@@문제13. 월급이 1000에서 3000사이인 사원들의 이름과 월급을 출력하시오!!
select ename, sal
from emp
where sal >=1000 and sal <=3000 ; 이렇게 하거나 where sal between 1000 and 3000 ;

@기타 비교 연산자
1. between .... and
2. like
3. is null
4. in
         
@@문제 14. 
oracleyu23@gmail.com 로 메일 제출하기
출석날짜,학번과 이름을 명시 화면캡쳐를해서

1981년도에 입사한 사원들의 이름과 입사일을 출력하시오!

select ename, hiredate
from emp
where hiredate between '81/01/01' and '81/12/31';




@@문제 15. 직업이 SALESMAN 인 사원들의 이름과 월급과 직업을 출력하시오. 

select ename, sal, job
from emp
where job = "SALESMAN" ;


@@문제 16. 부서번호가 30번인 사원들의 이름과 월급과 부서번호와 이름을 출력하는데,
         월급이 낮은 사원부터 높은 사원순으로 출력하시오.

                                                              [ Order by 절 ]   = 차순
select ename, sal, empno
from emp
where deptno = 30
order by sal asc ;

- asc : ascending 하게 출력 (낮은 값 부터, 높은 값 순으로)
- desc : decending 하게 출력 (높은 값 부터, 낮은 값 순으로)

@@문제 17. 월급이 2000 이상인 사원들의 이름과 월급과 입사일을 출력하는데,
         최근에 입사한 사원부터 출력하시오.

Select ename, sal, hiredate
from emp
where sal>= 2000
order by hiredate desc ;

                                                                               * Like 
@@문제 18. 이름의 첫번째 글자가 S로 시작하는 사원들의/ 이름과 월급을 출력하시오.

Select ename, sal
from emp
where ename like 'S%" ;
                                    * %가 의미하는 것은 Wild card 인데, 이 자리에 어떠한 철자가 와도 관계가 없고, 
                                      갯수가 몇개가 되도 관계없음

@@문제 19. 이름의 끝 글자가 T로 끝나는 사원들의 이름을 출력하시오.
Select ename
from emp
where ename like '%T' ;

@@문제 20. 이름의 두번째 철자가 M인 사원들의 이름을 출력하시오!

select ename
from emp
where ename like '_M%' ;                    * _ 바의 의미는 자릿수 이다.

@@문제 21. 이름의 세번째 철자가 L인 사원들의 이름을 출력하시오 !

Select ename
from emp
where ename like '__L%' ;

@@문제 22. 커미션이 null 인 사원들의 이름과 커미션을 출력하시오.

select ename, comm
from emp
where comm is null ;

                        * 기타 비교연산자 
                        1. between .. and
                        2. like 
                        3. is null
                        4. in

@@문제 23. 커미션이 null 이 아닌 사원들의 이름과 커미션을 출력하시오.

select ename, comm
from emp
where comm is not null ;

@@문제 24. 사원번호가 7788, 7902, 7369 번인 사원들의 사원번호와 이름을 출력하시오.

Select ename, empno
from emp
where empno = 7788 or empno = 7902 or empno = 7369 ;

where empno in (7788,7902,7369) ;

@@문제 25. 직업이 SALESMAN, ANALYst가 아닌 사원들의 이름과 직업을 출력하시오.

Select ename, job
from emp
where job
not in ('SALESMAN', 'ANALYST') ;
 



* 기타 비교연산자 
                        1. between .. and
                        2. like 
                        3. is null
                        4. in
   함수 : DATA를 함수에 입력하면 어떤 가공된 결과를 출력하는 것 DB object
          
         함수는 항상 결과를 리턴한다.

        1. 단일행 함수 : 하나의 DATA가 입력되어서 하나의 결과를 출력한다. 

   
  -----------data -------> function -------> 결과
                      
		- 문자 : upper 대문자 출력, lower 소문자 출력 , initcap 첫글자만 출력, substr 특정 철자를 짤라낸다, length, instr, rpad, lpad, trim  
		- 숫자 : 
		- 날짜
		- 변환
		- 일반

	2. 복수행 함수 ( = group 함수)
		      : max, min, avg, sum, count
        
           여러개의 data 행이 입력되어서 하나의 결과로 출력되는 함수를 의미한다.


-----Data--->
-----Data--->   Function ------- 결과 ---------> 
-----Data--->



@@문제 26. 아래의 결과를 출력하시오.

select upper(ename), lower(ename), initcap(ename)
from emp ;

@@문제 27. 이름이 KING 인 사원의 이름과 월급을 출력하시오.

select ename, sal
from emp
where ename='KING'

@@문제 28. 위에 king을 소문자로 입력해서 결과가 출력되겠금 하시오.

Select ename,sal
from emp
where lower(ename)='king' ;

@@문제29. 아래의 결과를 출력하시오.

select ename, substr(ename, 1,2)       - substr 첫번째 자리의 1, 2 을 짤라낸다.
from emp;

@@문제 30. 이름을 출력하는 이름의 첫번째 철자만 출력하는데, 소문자로만 출력하시오.

select lower(substr(ename, 1,1))
from emp;

                                      -length -> 철자의 갯수를 세는 함수
@@문제 31. 아래의 결과를 출력하시오

select ename, length(ename)
from emp ; 

@@문제 32. 이름의 철자의 갯수가 5개 이상인 사원들의 이름과 이름의 철자의 갯수를 출력하시오.

select ename, length(ename)
from emp
where length(ename)>=5 ;

                                       - Instr 함수 -> 특정 철자가 몇번째 자리에 있는지 출력하는 함수

select ename, instr(ename, 'A' )
from emp;

@@문제 33. 이름에 L 자를 포함하고 있는 사원들의 이름을 출력하시오.

Select ename
from emp
where instr(ename, "L') >= 1 ;   *1 도 되고 0도 된다!

select ename
from emp
where ename like '%L% ' ; 

                                     - Trim 함수 : 양쪽에 있는 공백을 잘라버리는 함수

Insert into emp(empno, ename, sal)
values ( 1122,' JACK ', 3000 ) ;  * JACK 입력시 공백을 줘야 된다! -> Trim 문제 풀려고^^;  *Rollback 은 취소인가봐!

@@문제 34. 이름이 JACK 인 사원의 이름과 월급을 출력하시오!

select ename
from emp
where ename = ' JACK ' ;


Select lpad(sal, 10, '*')     *Lpad : 왼쪽에 채워넣는다. 전체 10자리잡고, 왼쪽에 별표를 채워넣어라
from emp;

                                      *Rpad : 오른쪽에 채워넣는다, 10자리 잡고, 왼쪽에 별표를 채워넣는다

select length(rpad(sal, 10, ' ') -> 문잣수를 세잖아!

@@문제 35. 직업이 SLAESMAN이 아닌 사원들의 이름과 월급과 직업을 출력하는데, 직업을 소문자로 출력하고
         월급이 높은사원부터 출력하시오.

select ename, sal, lower(job)
from emp
where job is not ('SALESMAN')
order by sal desc and ; 


" 오늘 마지막 문제 " 
  
  이름과 입사한년도(4자리)와 월급과 보너스를 출력하는데 
  입사한 년도가 1980년도이면 보너스를 5000 으로 출력하고,  
  입사한 년도가 1981년도이면 보너스를 4000 으로 출력하고,
  나머지 년도는 그냥 0으로 출력하시오. 

Select hiredate, sal, bonus
from emp


         


 * 보너스 테이블을 만들다. use 함수

숫자함수
1.round -> 반올림하는 함수
2.trunc -> 반올림안하고 잘라내는 함수
3.mod -> 나눈 나머지값을 출력하는 함수

@ round
	select round(785.878, 1)  
	from dual;
소숫점 1째자리까지 반올림하는거!!

	select round(785.878, 0)
	from dual;
	select round(785.878 )
	from dual;
	위 두개가 같다!

		785.878
		   0123
	dual -> 결과값을 보기위한 가상의 테이블


@@문제36. 이름, 월급, 월급 * 0.24 를 출력하는데 소숫점이하는 안나오게 반올림해서 출력하시오

	select ename , sal , round(sal*0.24 , 0)
	from emp;

@trunc
select trunc(785.878, 1)  
	from dual;
잘라내는 함수! (다 버려버리는...)
7 8 5 . 8 7 8
      0 1 2 3   2 3 은 다 버리는거...

@mod -> 나는 나머지값
 10을 3으로 나누면 나머지값.. 1이다
select mod (10 , 3)
from dual ;

@날짜함수
1.날짜 - 날짜 = ? ==숫자
2.날짜 - 숫자 = ? ==날짜
3.날짜 + 숫자 = ? ==날짜

@오늘 날짜를 보는 방법
select sysdate
from dual ;

@@문제37. 이름, 입사일, 입사한 날짜부터 오늘까지 총 몇일 근무했는지 출력하시오
select ename , hiredate , sysdate - hiredate
from emp;

@@문제 38. 위의 결과에서 소숫점이하는 안나오게 반올림하시오!
select ename , hiredate , round(sysdate - hiredate , 0)
from emp;

@@문제39. 위의 결과를 다시 출력하는데 총 몇달 근무했는지 출력하시오

@months_between -> 날짜와 날짜사이의 개월수를 출력하는 함수
select ename, months_between(sysdate,hiredate) 괄호안은 날짜 순으로....
from emp;

@@문제 40. 이름, 입사한 날짜부터 오늘까지 받은 총 급여를 출력하시오!
select ename , months_between(sysdate,hiredate)*sal
from emp;

@ add_months -> 날짜에서 개월수를 더한 날짜를 출력

@@문제 41. 오늘날짜에서 100달 뒤의 날짜가 무엇인가?
select add_months(sysdate,100)
from dual ;

@ next_day -> 지정된 날짜에서 지정된요일에 돌아오는 날짜를 출력

@@문제42. 오늘날짜에서 앞으로 돌아올 금요일의 날짜를 출력하시오!
select next_day (sysdate, 'friday')
from dual;

@@문제43. 오늘날짜에서 앞으로 돌아올 목요일의 날짜를 출력하시오
select next_day (sysdate, '목요일') <- 요일은 영어로 될 수도 있고 한글로 될 수도 있다...
from dual;

@함수를 중첩해서 사용할수있다.
@@문제44. 오늘부터 100달 뒤에 돌아오는 월요일의 날짜를 출력하시오!
select next_day( add_months(sysdate,100), '월요일')
from dual;

@last_day -> 지정된 날짜의 달의 마지막날짜를 출력하는 함수

@@문제45. 요번달의 마지막 날짜를 출력하시오!
select last_day(sysdate)
from dual ;

@@문제46. 오늘부터 요번달 말일까지 총 몇일 남았는지 출력하시오 !
select last_day(sysdate) - sysdate
from dual ;

@변환함수
@형(data type)
 1.문자형 2.숫자형 3.날짜형
@형변환 2가지 
1.암시적 형변환

	select ename, sal
	from emp
	where sal = 3000;
	      숫자  숫자

	select ename, sal
	from emp
	where sal = '3000'; 싱글쿼테이션 마크를 썻다는것은 안에 들어있는것을 문자로 인식하라고 한거
	      숫자  문자
	      숫자가 문자보다 우선순위가 높아서 숫자 >문자
	      그래서 문자를 숫자로 바꿔서
	      숫자  숫자 가 되는 것임.....(하지만 성능이 떨어지기때문에 숫자로 쓰는것이 옳다)

2.명시적 형변환 (4-8p 참조)
	1. to_char 
	2. to_number
	3. to_date

select ename, sal, to_char(sal, '999,999') <- 금융권 등등에서는 중간에 콤마 있는게 좋기때문에,.... 9가 의미하는것은 자릿수
from emp;

			숫자 ----> 문자

@@문제47. 이름, 월급, 월급*56000 출력하는데 월급*56000의 결과를 출력할때에 천단위와 백만단위를 표시하시오
select ename , sal ,to_char(sal*56000, '999,999,999')
from emp;

@ 날짜 ------>문자
select ename, hiredate, to_char(hiredate)
from emp;


@@문제48. 이름 , 입사일, 입사한 년도 4사리를 출력하시오!
select ename, hiredate, to_char(hiredate, 'RRRR')
from emp;

select ename, hiredate, to_char(hiredate, 'YEAR')
from emp;

년도: RRRR, YYYY, RR, YY
달: MM,MON
일: DD
시간:HH24
분:MI
초:SS
요일:DAY

@@문제49. 이름, 입사일, 입사한요일을 출력하시오
select ename, hiredate, to_char(hiredate, 'day')
from emp;

스터디과제
주제: 1.주제를 받고
      2.스터디를 하고
      3.ppt생성해서 토요일밤까지 메일로 제출 (교수님 메일...)
      4. 평가, 발표 
 주제: -날짜형식중에 ww와 iw의 차이를 설명하고 실습자료를 생성하시오 !
       -수업시간에 배웠던 내용중에 선별해서 발표 ppt 생성 발표




@날짜형식 RR과 YY의 차이

@@문제50. 81년 2월 11일에 입사한 사원의 이름과 입사일을 출력하시오!

select ename, hiredate
from emp
where hiredate = '81/02/23';

@@문제51. 현재 접속한 세션의 날짜형식을 확인하는 방법?
select *
from nls_session_parameters;

여기서 NLS_DATE_FORMAT 이부분 확인
바꾸는 방법 alter session set nls_date_format = 'RR/MM/DD';

	RR          YY
        81          81
     1981 2081   1981 2081
       2015         2015

현재연도에서가장  현재세기
가까운연도       2081을 인식
1981을 인식
YY의 날짜형식일 경우에는 NO ROWS SELECTED 라는 오류 메세지가 나온다....
예전에는 YY만 지원했는데 2000년도 이후에 RR이라는 날짜형식을 오라클에서 지원하게되서 문제가 생기지 않게되었다..
현업에서는 날짜를 분명하게 4자리로 모두 검색한다

문제 52. 날짜를 1982년 2월 11일에 입사한 사원의 이름과 입사일을 출력하시오!(절대로 에러안나고 결과가 출력되게 하시오!)
1982/02/11에 해당하는 날짜에 입사한 사원이 없다 ㅠㅠ
@변환함수
1. to_char
2. to_number
3. to_date ->날짜로 형변환하는 함수

select ename , hiredate
from emp
where hiredate = to_date('1981/02/23' , 'rrrr/mm/dd');

순서를 바꾸고 싶으면

select ename , hiredate
from emp
where hiredate = to_date('23/02/1981' , 'dd/mm/rrrr');


@일반함수
1. nvl함수     ->null값 대신에 지정된 값이 출력되게 해라~
2. decode 함수 -> if - than - else 구조의 함수
3. case 함수   -> if - than - else 구조의 함수

@@문제 53. 이름과 커미션을 출력하시오

select ename , comm
from emp;


@ null 값 -> 1.data가 없는상태
             2. 알수없는값


@@문제54. 이름과 커미션을 출력하는데 커미션이 null인 사원들은 0으로 출력되게하시오!
select ename, nvl(comm,0)        nvl은  널값이 아니면 그냥 출력하고 널값이면 0이 출력 되도록하는것
from emp;

@@문제55. 이름, 월급, 커미션, 월급 + 커미션을 출력하시오
select ename , sal, nvl(comm,0), sal+nvl(comm,0)
from emp;
월급 + 커미션으로 그냥 출력하면은 그 값이 출력되지 않음... 커미션 값이 알수 없는 값으로 설정되어있기 때문에...

@@문제56. 이름, 월급, 커미션을 출력하는데 커미션이 null인 사원들은 no comm이란 문자로 출력되게 하시오
select ename, sal, nvl(to_char(comm) ,'no comm' )    <- 둘의 데이터 타입을 같게 해야되기 때문에!!!! 문자로 형변환
from emp ;

@@문제57. 이름 mgr(관리자의 사원번호) 를 출력하는데 mgrdl null인 사원들은 no manager 란 문자로 출력되게하시오!
select ename, nvl(to_char(mgr), 'no manager')
from emp;



@ decode 함수 -> if - then - else 구조의 함수

@@문제58. 이름, 월급, 부서번호, 보너스를 출력하는데 부서번호가 10번이면 5000으로 출력
부서번호가 20번이면 3000으로 출력하고 나머지 부서번호면 0으로 출력하시오!

select ename, sal, deptno,
	decode(deptno, 10,5000,
		      20,3000,0) bonus
from emp;

@@문제 59. 이름, 직업, 월급, 보너스를 출력하는데 보너스가
직업이 salesman 이면 자신의 월급에 10%로 출력하고 직업이 analyst 면 자신의 월급에 20%로 출력하고 나머지 직업은 그냥 0으로 출력하시오!
 
select ename, job, sal ,
	decode(job, 'SALESMAN', sal*0.1 , 'ANALYST' , sal*0.2 , 0) bonus  <= 직업 대문자로 해야됨
from emp;


@@문제60. 이름, 입사년도(4자리), 월급, 보너스를 출력하는데 보너스가 입사한 년도가 1981년이면 500으로 출력하고
그렇지 않으면 0으로 출력하시오
select ename, to_char(hiredate, 'RRRR'), sal,
	decode( to_char(hiredate, 'RRRR') , 1981 , 500, 0) bonus
from emp;

@@문제61. 이름, 월급, 보너스를 출력하는데
	보너스가 자기의 월급이 3000이상이면 500으로 출력되게하고 자기의 월급이 2000이상이고 3000보다 작으면 200으로
	출력되게 하고 자기의 월급이 2000보다 작으면 0으로 출력되게 하시오 <- 이 예제는 디코드를 사용하면 안된다 케이스문으로 해야된다

@decode와 case문의 차이점은?
decode문은 = 비교만 가능하다
case문은 = 비교 뿐만아니라 부등호 비교도 가능하다. case예제는 4-8쪽을 참고한다


select ename, sal ,
	case when sal >= 3000 then 500
	     when sal >= 2000 then 200       각각의 whem에서 걸러지기 때문에 =<3000 이럴 필요 없다....
	     else 0 end bonus
from emp;

@@문제62. 위의 문제 59번을 case문으로 구현하시오!

select ename, sal, job,
	case job when 'SALESMAN' then sal*0.1
		 when 'ANALYST'  then sal*0.2
             else 0 end bonus
from emp;

select ename, sal, job,
 	case when job = 'SALESMAN' then sal*0.1
	     when job = 'ANALYST' then sal*0.2
	     else 0 end bonus
from emp;

@@과제1. 스터디과제가 아니라 개인과제인데 메일로 발송할 때에 텍스트를 성의없이 보내지 말고 이번에 사용한 조별ppt 형식에 화변캡쳐해서 발송하시오!

이름, 부서번호, 월급, 보너스를 출력하는데
보너스가 부서번호가 10번이면 자기의 월급에 30%로 출력
20번이면 자기의 월급에 20%로 출력하고 나머지 부서번호면 그냥 0이 출력되게 하는데 보너스가 아래와 같이 출력되게 하시오

          bonus
	 3,000  <=== 천단위를 부여해서 출력
	 2,000
과제 보낼때  sql결과와 명령문 같이 보내기 자기 조에서 썻던 피피티를 이용해서 보내기 예쁜 형식을 이용해서 피피티로
sql결과와 명령문으로 
토요일까지


select ename, deptno, sal,
       case when deptno = 10 then to_char(sal*0.3, '999,999,999')
            when deptno = 20 then to_char(sal*0.2, '999,999,999')
            else to_char(0, '999,999,999') end bonus
from emp;


select ename, deptno, sal,
       decode( deptno , 10 , to_char(sal*0.3, '999,999,999'), 
	                20 , to_char(sal*0.2, '999,999,999'), 
                        to_char(0, '999,999,999') ) bonus
from emp;

decode( to_char(hiredate, 'RRRR') , 1981 , 500, 0) bonus

5장. GROUP 함수

* 함수의 종류

 1. 단일행 함수
 2. 복수행 함수 (=Group함수)

* Group 함수의 종류

	 1. Max -> 최대값 출력
	 2. Min -> 최소값 출력
 	3. Avg -> 평균값 출력
 	4. Count -> 건수를 세는 함수
	 5. Sum   -> 토탈값 출력

--------------------------------------------------------------------------

@@문제63. 최대월급을 출력하시오.

 select max(sal)
from emp;

--------------------------------------------------------------------------

@@문제 64. 직업이 SALESMAN인 사원들중에서의 최대월급을 출력하시오!
select max(sal)
from emp
where job = 'SALESMAN';

@@문제 65. 20번 부서번호인 사원들중에서의 최대월급을 출력하시오!

select max(sal)
from emp
where deptno = '20';

@@문제 66. 위의 SQL을 수정해서 아래와 같이 결과가 출력되게 하시오!

deptno   max(sal)
-----    -------
 20      3000

select deptno, max(sal)
from emp
where deptno = '20'
group by deptno;   

* group by 절의 역활?
   grouping을 하는 역활

---------------------------------------------------------------------------
@@문제 67. 아래와 같이 결과를 출력하시오!


1  select job, max(sal)
4  from emp
2  where job = 'SALESMAN'
3  group by job;

job       max(sal)
-----      -------
SALESMAN  1600

== SALESMAN 들 중 최대월급)


-----------------------------------------------------------------------------


@@문제 68. 위의 결과에서 where 절을 빼면 어떠한 결과가 나오게 될까요?!

1 select job, max(sal)
3 from emp
2 group by job;

== 직업별 최대월급)


@@문제 69. 부서번호, 부서번호별 최대월급을 출력하시오.

select deptno, max(sal)
from emp
group by deptno



@@문제 70. 위의 결과를 다시 출력하는데, 부서번호별 최대월급이 높은 것 부터 출력하시오.

select deptno, max(sal)
from emp
group by deptno
order by max(sal) desc; 

@@문제 71. 직업, 직업별 최소월급을 출력하는데 직업이 SALESMAN 은 제외하고 출력하시오.

select job, min(sal)
from emp
where job != 'SALESMAN'
group by job ;

[    ^=, != , <> 전부다 아닌(not)을 표현하는 함수     ]


@@문제 72. 중간고사형 문제 // 커미션이 null인 사원들중에서의 최소월급을 출력하시오!

select min(sal)
from emp
where comm is null ;        <- 시험때는 전부다 한글기술이기 때문에, is로 쓰기!

@@문제 73. 시험문제식. 직업, 직업별 최소월급을 출력하는데, 직업별 최소월급이 2000 이상인 것만 출력하시오!

select job, min(sal)
from emp
where min(sal) >= 2000
group by job ;

group function is not allowed here (그룹함수는 이 줄에서 못쓰여요!)

-> 그렇다면? 다른 절에 써줘야 되는거야!!

select job, min(sal)
from emp
group by job 
having min(sal) >= 2000 ;

* 그룹함수를 이용한 검색조건은 where 절이 아닌 having 절을 사용해줘야 한다!!
  이 having 절은 group by 다음에 써줘야 되는거야!!

group by ~~
having ~~

* select 문의 6가지 절★

oracle 실행 순서

5	select
1	from
2	where
3	group by
4	having
6	order by 

-----------------------------------------------------------------------------------

@@문제 74. 직업, 직업별 최대월급을 출력하는데, 직업이 SALESMAN 은 제외하고 출력하고, 직업별 최대월급이 3000 이상인 것 만 출력하고,
	 그리고, 직업별 최대월급이 높은 것 부터 출력하는데, 컬럼명이 한글로 직업, 최대월급 이렇게 나오게 하시오.

select job "직업", max(sal) "최대월급"               = 또는 job as 직업, max(sal) as 최대월급 " " 써도 되고요! 
from emp
where job != 'SALESMAN'
group by job
having max(sal) >= 3000
order by max(sal) desc ;


" " 은 숫자나, 공백을 처 넣을때만 가능 

------------------------------------------------------------------------------------

평균값을 구하는 avg 를 사용

@@문제 75. 사원 테이블에서 평균월급을 출력하시오.
         소수점 이후는 안나오게 반올림 하시오

select round(avg(sal))
from emp;

----------------------------------------------------------------------------------------

@@문제 76. 커미션의 평균값을 출력하시오.

select avg(comm)
from emp ;

* Group 함수의 특징 !! Group 함수는 null 값을 무시한다. ( 무시한다는 의미는 취급을 안해버린다.)
  숫자 0 은 Null 이 아니야 ! 

3000 + 0 = 3000
3000 + null = null

--------------------------------------------------------------------------------------

@@문제 77. 커미션의 평균값을 출력하는데, 4로 나누는 것이 아니라 14로 나누겠금 출력하시오!
         
select avg(nvl(comm,0))
from emp;

---------------------------------------------------------------------------------------

@@문제 78. 아래의 2개의 SQL 중 어떠한 SQL 이 더 효율적인 SQL 인가?

select sum(comm) from emp; ★ 중간고사때, 위의 것이 더 효율적이라고 답을 해주면 돼!

select sum(nvl(comm,0)) from emp ; 

그룹함수는 null 값을 무시하잖아, comm인 null 값인 애들을 무시해버리잖아
밑에 거의 경우는 comm이 null인 애들을 0 으로 만든거잖아. 그럼 0 0 0 0 0 0 0 1400 + 300 + 0 + 0 + 0 
쓸데 없는 연산을 해버리잖아!

----------------------------------------------------------------------------------------

@@문제 79. 부서번호, 부서번호별 토탈월급을 출력하는데 부서번호별 토탈월급이 3000 이상인 경우만 출력하시오.

select deptno, sum(deptno)
from emp
group by deptno
having sum(sal) >= 3000 ;

-------------------------------------------------------------------------------------

@@문제 80. 입사한 년도(4자리), 입사한 년도별 토탈월급을 출력하는데 입사한 년도별 토탈월급이 높은 것 부터 출력하시오.

select to_char(hiredate, 'RRRR'), sum(sal)
from emp
group by to_char(hiredate, 'RRRR')
order by sum(sal) desc;

--------------------------------------------------------------------------

-Count 함수 -> 건수를 세는 함수

@@문제 81. 사원 테이블의 전체 사원수가 몇 명인지 확인하시오.

select count(empno)
from emp;

사원번호로 셌을 경우에는, 사원번호만 하나씩 센다. 

select count(*)
from emp;

*는 한 줄을 전부다 세어버린다.

---------------------------------------------------------------------------

@@문제 82. 직업, 직업별 인원수를 출력하시오.

select job, count(*)
from emp
group by job ;

-------------------------------------------------------------------------

@@문제 83. 직업, 직업별 토탈월급을 출력하는데, 직업별 토탈월급을 출력할 때 천단위가 표시되게 하시오!

select job, to_char(sum(sal), '9,999')
from emp
group by job;

--------------------------------------------------------------------------

*중간고사를 공부하면서 이거는 시험문제로 나왔으면 좋겠다는 문제를 개인적으로 만들어서 토요일 자정까지 제출
시험출제자 이름과 문제 잘 만들어서 내야된다

*조인(join)
  - 조인이란?
	여러개의 테이블의 컬럼들의 결과를 하나의 결과값으로 출력하기 위한 방법

select *
from dept;

deptno : 부서번호
dname : 부서명
loc : 부서위치

@@문제84. 이름, 부서위치를 출력하시오!

	emp와 dept 가 서로 연관이 있다라는 연결고리를 where절에 기술을 해줘야 한다.

select ename, loc
from emp,dept
where emp.deptno = dept.deptno ;

@@문제85. 사원번호, 이름, 월급, 부서위치, 부서번호를 출력하시오!
select empno, ename, sal , loc , emp.deptno  <- emp테이블에 있는 deptno 로 해야됨.... 또는 dept.deptno로 해야됨...
from emp, dept
where emp.deptno = dept.deptno;

emp.empno 는 할필요가 없음.... 어차피 empno 는 emp 테이블에밖에 없으니까....  하지만 써줘야 된다!!!! 성능이 좋아진다!! 안 찾아보고 검색을 할 수 있으니까
앞에다가 테이블 명을 써줘야 된다!!!!!!

select e.empno, e.ename, e.sal , d.loc , e.deptno  
from emp e, dept d
where e.deptno = d.deptno;


emp 는 e라고 한 이유가?
 코딩을 쉽게하기 위해서


select emp.empno, e.ename, e.sal , d.loc , e.deptno    <- emp.empno 이렇게 하면 안된다....
from emp e, dept d     <-이 문장에서 emp는e dept 는 d로 바뀐것임....
where e.deptno = d.deptno;

@@문제86. 직업이 SALESMAN 인 사원들의 이름과 직업과 부서위치를 출력하시오!   SALESMAN대문자로 해야됨!!!
select ename , job , loc
from emp e, dept d
where e.deptno = d.deptno and <-연결고리!!
      e.job = 'SALESMAN' <-검색조건!!


@@문제87. 월급이 3000 이상인 사원들의 이름과 월급과 부서위치를 출력하시오!

select ename, sal, loc
from emp e, dept d
where e.deptno = d.deptno and
 sal>= 3000 ;

@@문제88. DALLAS 에서 근무하는 사원들의 이름과 부서위치를 출력하시오!
select ename, loc
from emp e ,dept d
where e.deptno = d.deptno and
      d.loc = 'DALLAS' ;


@@문제89. 월급이 1000에서 3000사이인 사원들의 이름과 월급과 부서위치
select e.ename, e.sal, d.loc
from emp e, dept d
where e.deptno = d.demptno
and e.sal 1000 between 3000 ;

@@문제90. 부서위치, 부서위치별 토탈월급을 출력하시오!  <-이런스타일이 중간고사 문제
select loc , sum(e.sal)
from emp e, dept d
where e.deptno = d.deptno
group by d.loc;


중간고사 쓸 때 소문자로!!!!!!!! 글씨 또박또박

@@문제91.  위의결과에서 부서위치별 토탈월급이 9000이상인것만..

select loc , sum(e.sal)
from emp e, dept d
where e.deptno = d.deptno
group by d.loc
having sum(e.sal) >=9000;

시험 문제는 조금 바꿔서!!!! 시험공부는 지금까지 했던 문제들 위주로!!

@@문제92. 부서위치, 부서위치별 인원수를 출력하는데// 부서위치가 DALLAS는 제외하고 출력하고/ 부서위치별 인원수가 3명이상인 것만/ 출력하고
부서위치별 인원수가 높은것부터 출력하시오 <-중간고사 문제 스타일!!!!



가장 정확안 것은 카운트 별표 또는 count(e.empno)   시험볼때는 별표를 쓰자
select d.loc, count(*)     
from emp e, dept d
where e.deptno = d.deptno 
      and d.loc<>'DALLAS'
group by d.loc
having count(*) >=3     <-and d.loc<>'DALLAS'이 조건은 웨어절에 쓸것 해빙절에 쓰면 안된다 성능이 느리다....
order by count(*) desc;


*다음주 시험 시험시간은 7시 30분이고 1시간에서 1시간 30분 정도로 시험 15문제에서 20문제 나오는데 대부분sql작성하는것이 나오고
손으로 작성하는것 emp와 dept 결과창은 첨부해서 보여주심 공부 방법은 sql 문제92문제를 직접 풀어보고 문제를 만든다는 생각으로 응용을 하면된다
토요일 자정까지 문제 1문제를 만들어서 제출하면 시험지에 선별해서부분점수는 없다고 보는것이 좋다!! 많이 어렵지 않으므로



@@문제93. 1981년도에 입사한 사원들의 이름과 월급과 부서위치와 입사일을 출력하시오!

select e.ename, e.sal, d.loc , e.hiredate
from emp e, dept d
where e.deptno = e.deptno and to_char(e.hiredate , 'rrrr') = 1981 ;





@조인의 종류
1.오라클 조인문법
	-equi join -> 조인하려는 테이블 사이의 연결고리가 =(이퀄) 조건인경우
	-non equi join -> 조인하려는 테이블 사이의 연결고리가 =(이퀄) 이 아닌경우
	-outer join -> equi join 으로 조인 안된 결과를 볼 때 사용하는 조인
	-self join -> 자기자신의 테이블과 조인하는 조인
2.1999 ansi 조인문법

문제94. 부서번호가30번인 사원들의 이름 부서위치 월급 부서번호를 출력하시오
select e.ename , d.loc , e.sal , e.deptno
from emp e , dept d
where e.deptno = d.deptno and e.deptno = 30;   <- equi조인!!!

@grade -> 급여등급!!!

문제95. 이름, 월급, grade(급여등급)을 출력하시오!
select e.ename , e.sal , s.grade
from emp e , salgrade s
where e.sal between s.losal and s.hisal ; <-사이에 있다는 의미로!!!! 이게바로 non eui join 이다

문제96. 위의 결가에서 급여등급이 1등급인 사원들만 출력하시오
select e.ename , e.sal , s.grade
from emp e , salgrade s
where e.sal between s.losal and s.hisal and s.grade = 1;

 * outer join
문제97. 이름, 부서위치를 출력하는데 부서 테이블에서 안나온 부서위치가 무엇인지 확인하시오
select e.ename, d.loc
from emp e , dept d
where e.deptno = d.deptno;

문제98. 왜 boston이 안나 왔을까? 
emp 테이블에 40번의 부서를 갖고 있는 부서의 사람이 없어서....(emp부서에서는 10 20 30 번의 부서 사람이 없다...)
40번의 사람이 없기 때문에 조인이 안된거임 그래서 보스턴이 안나온것임

문제99. 어느 부서위치에 사원이 배치되지 않았는지 아래 처럼 확인하고자 한다면
테이블에  (빈칸)	boston 이렇게 추가되서 나오는 것
select e.ename , d.loc
from emp e , dept d
where e.deptno (+) = d.deptno; 

	(+) <--outer join sign: outer join sign은 모자란쪽에다 붙여주면 된다...

<-이거 삽입하고 100번 풀기!!
insert into emp(empno,ename,deptno)
 values (2934,'JACK',70);

문제100. 사원이름, 부서위치를 출력하는데 아래와 같이 결과가 출력되게 outer join을 쓰시오

JACK  (빈칸) <- 이렇게 나오게 출력하라는것!!!
select e.ename , d.loc
from emp e , dept d
where e.deptno =  d.deptno (+);

문제101. 부서위치, 부서위치별 토탈월급을 출력하시오!
select d.loc, sum(sal)
from emp e , dept d
where e.deptno(+) = d.deptno
group by d.loc;


문제102. 
위의 결과에 보스턴은 0이 나오도록 출력하시오
select d.loc, nvl(sum(sal) , 0)
from emp e , dept d
where e.deptno(+) = d.deptno
group by d.loc;

문제103. 아래의 결과를 출력하시오
JACK (빈칸)
(빈칸)BOSTON   양쪽다 추가되서 나오도록!!
select e.ename , d.loc
from emp e , dept d
where e.deptno(+) = d.deptno(+);  <--이렇게 하면안된다!!

1999 ansi 문법이 필요!! (america national standard institute)
 - full outer join 문법

select e.emp , d.loc
from emp e full outer join dept d             //이 부분 모르겠음.... 안돌아감
on(e.deptno = d.deptno);

문제104. 부서위치,  부서위치별 인원수를 출력하는데 부서위치별 인원수가 3명이상인것만 출력하시오
select d.loc , count(*)
from emp e , dept d
where e.deptno = d.deptno
group by d.loc
having count(*)>=3;

문제105. 급여등급(grade), 급여등급별 인원수를 출력하시오!
select s.grade , count(*)
from emp e , salgrade s
where e.sal between s.losal and s.hisal
group by s.grade;

문제106. 사원번호, 이름, mgr(관리자번호<-자기의 관리자, 자기의 직속상사의 사원번호!!) 를 출력하시오
select e.empno , e.ename , e.mgr
from emp e;


@관리자 관계
위로 갈수록 관리자
   7839 king <-이친구가 사장임
  7566 jones
 7902 ford
7369 smith


문제107. 사원이름, 자기의 직속상사(자기의 관리자)의 이름을 출력하시오

select 사원.ename , 관리자.ename     <-이게 self 조인이다!!
from emp 사원 , emp 관리자
where 사원.mgr = 관리자.empno;
결과가 13명임 사원은 14명인데.... (king이 안나온것임..)

문제108. 위의 결과에서 king이 출력되게 하시오

select 사원.ename , 관리자.ename     
from emp 사원 , emp 관리자
where 사원.mgr = 관리자.empno(+);   <-self join에 outer join을 해줘야 된다


1.오라클 조인문법
	-equi join -> 조인하려는 테이블 사이의 연결고리가 =(이퀄) 조건인경우
	-non equi join -> 조인하려는 테이블 사이의 연결고리가 =(이퀄) 이 아닌경우
	-outer join -> equi join 으로 조인 안된 결과를 볼 때 사용하는 조인
	-self join -> 자기자신의 테이블과 조인하는 조인
2.1999 ansi 조인문법

	-full outer join 문법

2개의 테이블을 조인하려면 연결고리가 한개는 있어야 한다!!

emp----------------------dept
 	연 결 고 리
3개의 테이블을 조인하려면 연결고리가 몇개가 있어야할까?
dept ---------------emp ---------------salgrade
       연결고리            연결고리

문제109. 사원이름, 월급, 부서위치, 급여등급(grade)을 출력하시오
select e.ename , e.sal ,d.loc , s.grade
from emp e, dept d, salgrade s
where e.deptno=d.deptno and e.sal between s.losal and s.hisal;

과제. 1.중간고사 정답을 달아서 메일발송 
      2.틀린갯수

마지막문제. 급여등급이 3등급인 사원들의 부서위치, 부서위치별 최대월급을 출력하는데// 부서위치별 최대월급이 1000이상인것만출력하시오
select d.loc, max(sal)
from emp e, dept d,salgrade s
where e.deptno = d.deptno and e.sal between s.losal and s.hisal and s.grade = 3
group by d.loc
having max(sal)>=1000;




문제111. 최대 월급을 받는 사원의 이름과 월급을 출력하시오 (아무나 스킬것임)
*subquery 를 사용해야된다
select ename , sal
from emp
where sal = (select max(sal)
             from emp);

문제112. jones의 월급보다 더 많은 월급을 받는 사원들의 이름과 월급을 출력하시오

select ename , sal   <-main query
from emp
where sal > ( select sal           <-subquery
              from emp 
              where ename = 'JONES');    <-괄호안에 넣어준다!!
오라클은 실행할 떄 서브쿼리부터 실행한다 ㅋㅋㅋㅋ


113. SCOTT 과 같은 월급을 받는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal = (select sal
             from emp
             where ename = 'SCOTT')


114. 위의 결과에서 SCOTT은 제외하고 출력하시오!
select ename , sal
from emp
where sal = (select sal
             from emp
             where ename = 'SCOTT')
      and ename != 'SCOTT';


115. ALLEN과 같은 부서번호에서 근무하는 사원들의 이름과 부서번호를 출력하시오
select ename , deptno
from emp
where deptno = (select deptno
                from emp
                where ename = 'ALLEN');
여기서 엘렌을 제외하고 넣으라고 할때는
      and ename != 'ALLEN'; 넣으면됨


문제 116. ALLEN보다 늦게 입사한 사원들의 이름과 입사일을 출력하시오
select ename , hiredate
from emp
where hiredate > (select hiredate
                  from emp
                  where ename = 'ALLEN');


문제117. DALLAS에 있는 부서번호에서 근무하는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp 
where deptno = (select deptno
                from dept
                where loc = 'DALLAS');


문제118. 직업이 SALESMAN 인 사원들의 최대월급보다 더 많은 월급을 받는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal > (select max(sal)
             from emp
             where job = 'SALESMAN');


문제119. 최대 월급을 받는 사원의 이름과 월급을 출력하시오 
select ename , sal
from emp
where sal = (select max(sal)
             from emp);


문제120.KING에게 보고하는 사원들의 이름과 월급을 출력하시오 (KING의 직속부하 사원들)
select ename , sal
from emp
where mgr = (select empno
            from emp
            where ename = 'KING');


문제121. 직업이 SALESMAN인 사원들과 같은 월급을 받는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal in (select sal
            from emp
            where job = 'SALESMAN');

*subquery의 종류가 3가지
1.single row subquery : 
  서브쿼리에서 메인쿼리로 하나의 값이 리턴되는 경우
  이때 쓰여지는 연산자 : > , < , >= , <= , = , != , ^= , <> 
2.multiple row subquery :
  서브쿼리에서 메인쿼리로 여러개의 값이 리턴되는 경우
  연산자 : in , not in , >all , <all , >any , <any
3.multiple column subquery
  서브쿼리에서 메인쿼리로 여러개의 컬럽값이 리턴되는 경우
  

문제122. 직업이 SALESMAN 인 사원들과 월급이 같지않은 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal not in (select sal
                  from emp
                  where job = 'SALESMAN');
문제123. 관리자인 사원들의 이름을 출력하시오 (자기밑에 직속부하가 한명이라도 있는 사원들을 출력하시오)
select ename
from emp
where empno in(select mgr
               from emp);

문제124. 관리자가 아닌 사원들의 이름을 출력하시오

select ename
from emp
where empno not in (select mgr  <-not in쓸때는 null값 처리를 반드시 해야된다!
                    from emp);
 !=all
 !=(7566 and 7839 and ... and null)
 TRUE AND TRUE = TRUE
 TRUE AND FALSE= FALSE
 TRUE OR TRUE = TRUE
 TRUE OR FALSE = TRUE
 TRUE OR NULL = TRUE  <-NULL은 알수없는 값이기 때문에 TRUE 아니면 FALSE이다 근데 어차피 OR니까 무슨값이 나와도 TRUE이다
 TRUE AND NULL = NULL <-NULL이 알수 없는 값이기 때문에

따라서 위에 있는것 출력되게 하려면!
select ename
from emp
where empno not in (select mgr
                    from emp
                    where mgr is not null); <-이렇게 해줘야된다


문제125. 직업이 SALESMAN인 사원들중에서 가장 많은 월급을 받는 사원보다 더 많은 월급을 받는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal > (select max(sal)                   <-싱글로우 커리를 사용할떄
             from emp
             where job = 'SALESMAN');

select ename , sal
from emp
where sal >all (select sal                     <-멀티플로우 커리를 사용할떄, 여기서는 서브쿼리부터 실행한다
             from emp
             where job = 'SALESMAN');

>all(1000, 2000 , 3000) <-여기 괄호 안에 있는 모든 값보다 크다
>all 은 가장 큰 값보다 크다


문제126. 직업이 SALESMAN 인 사원들 중에서 가장 작은 월급을 받는 사원보다 더 많은 월급을 받는 사원들의 이름과 월급을 출력하시오
select ename , sal
from emp
where sal >any (select sal                  <-성능이 별로 안좋아서 안쓴다 max나 min을 주로 쓴다!!
                from emp
                where job = 'SALESMAN');
          혹은
 
select ename , sal
from emp
where sal > (select min(sal)
                from emp
                where job = 'SALESMAN');


문제127. 20번 부서번호인 사원들 중에서 가장 늦게 입사한 사원의 이름과 입사일과 부서번호를 출력하시오!
select ename , hiredate , deptno
from emp
where hiredate  = (select max(hiredate)
                  from emp
                  where deptno = 20);
3.multiple column subquery :
문제128. 30번 부서번호인 사원들과 월급도 같고 커미션도 같은 사원들의 이름과 월급과 커미션과 부서번호를 출력하시오

select ename, sal, comm, deptno
from emp
where sal in (select sal
                     from emp
                     where deptno=30)
and  comm in (select comm
                     from emp
                     where deptno=30);


-pair wise 방식
select ename, sal, comm, deptno
from emp
where (sal, comm) in (select sal, comm
                     from emp
                     where deptno=30);
  



문제 부서번호와 부서번호별 토탈월급을 출력하는데 맨 아래쪽에 전체 토탈 월급을 출력하시오

deptno      sum(sal)
10          9400
20          10875
30          8750

토탈        29025


문제129. 직업이 SALESMAN인 사원들과 월급이 같고 커미션도 같은 사원들의 이름과 월급과 커미션과 직업을 출력하시오!
-non pair wise 방식
select ename, sal, comm, job
from emp
where sal in (select sal
              from emp
              where job = 'SALESMAN')
and comm in (select comm
              from emp
              where job = 'SALESMAN');

-pair wise 방식(쌍을 이루는 방식)
select ename, sal, comm, job
from emp
where (sal, comm) in (select sal, comm
                      from emp
                      where job = 'SALESMAN');

@하나 인써트해보자
insert into emp(empno,ename,sal,comm,job)
values(1234,'JACK',1250,1400,'HR');

그 후에 다시한번 해보자!
select ename, sal, comm, job
from emp
where (sal, comm) in (select sal, comm
                      from emp
                      where job = 'SALESMAN');

select ename, sal, comm, job
from emp
where sal in (select sal
              from emp
              where job = 'SALESMAN')
and comm in (select comm
              from emp
              where job = 'SALESMAN');

둘다 돌아간다

문제130.
insert into emp(empno,ename,sal,comm,job)
values(1235,'JANE',1250,300,'HR');
위의 DATA를 입력하고 페어와이즈와 논페어와이즈 둘다 실행해보고 다른점을 찾아내시오
논페어가 하나 더 나온다!

왜 non pairwise 방식이 data가 더 많이 출력이 되냐면?
	(1250 , 1400)
	(1600 ,  300)
	(1500 ,    0)
	(1250 ,  500)
paire wise방식의 경우 위의 4가지 경우만 만족해야 결과가 출력된다.
	(1250 , 1400)
	(1250 ,  300)
	(1250 ,    0)
	(1250 ,  500)
	      .
	      .
	      .
	      .

non paire wise 방식의 경우는 4x4=16가지 경우를 만족해야된다!

@오라클은 pair wise 방식, non pair wise 방식 둘다 지원하는데 mssql,mysal 은 non pair wise방식만 지원한다.


@집합연산자의 종류 4가지

1.union all ->합집합 연산자   <-가장 많이 쓰인다!
2.union     ->합집합 연산자
3.intersect ->교집합 연산자
4.minus     ->차집합 연산자
@집합연산자로 할수 있는 작업?
여러개의 집합을 연결하는 작업


delete from emp where hiredate is null; <-null인거 다 지우기

문제131. 아래 처럼 부서번호, 부서번호별 토탈월급을 출력하시오!
deptno      sum(sal)
10          9400
20          10875
30          8750
select deptno , sum(sal)
from emp
group by deptno;

문제132. 아래와같이 결과를 출력하시오!

토탈        29025
select '토탈' , sum(sal)
from emp;

문제133. 아래와 같이 결과를 출력하시오
deptno      sum(sal)
10          9400
20          10875
30          8750
토탈        29025

select deptno , sum(sal)
from emp
group by deptno                 <-오류뜬다
union all
select '토탈' , sum(sal)
from emp;

@집합연산자를 사용할떄 주의사항
1.집합연산자 위 아래 쿼리의 컬럼의 갯수가 같아야한다
2.집합연산자 위 아래 쿼리의 컬럼의 data type이 같아야한다

select to_char(deptno) , sum(sal)
from emp
group by deptno
union all
select '토탈' , sum(sal)
from emp;

set pages 4000
set lines 4000                        <-이렇게 하면 한줄로 나옴!
/

문제134. 직업, 직업별 토탈월급을 출력하는데 맨 아래쪽에 전체 토탈월급을 출력하시오
select job, sum(sal)
from emp
group by job
union all
select '토탈' , sum(sal)
from emp;

select job, sum(sal)
from emp
group by job  
union all
select null , sum(sal)        <-이렇게도 가능함 하지만 토탈을 넣는것이 더 보기 좋음 ㅎㅎ
from emp;

문제135. 직업,직업별 인원수를 출력하고 맨 아래쪽에 전체 인원수를 출력하시오
select job , count(*)
from emp
group by job
union all
select '전체 인원수' as job , count(*)  <-as job 이것을 넣어줘야 된다 정확하게 하려면!!
from emp;

select job , count(*)
from emp
group by job
union all
select to_char(null) as job , count(*)  <-null을 넣을때 정확하게 하려면!! 이렇게 해야된다
from emp;

문제136. 위의sql을 rollup 함수를 이용해서 emp테이블을 한번만 select 해서 똑같은 결과가 출력되게하시오!
select job, count(*)
from emp
group by rollup(job); 

<-전체를 출력하게 하는 함수 roll up








과제. 토요일 밤까지 제출해야하는 과제
아래의 결과를 roll up으로 해서 출력하시오
deptno sum(sal)
10        9400
20        10875
30        8750
토탈      29025


select case when deptno is null then nvl(to_char(deptno), '토탈') 
            else to_char(deptno) end deptno , sum(sal) 
from emp
group by rollup(deptno);










오늘의 마지막 문제: 입사한 년도(4자리), 입사한 년도별 토탈월급을 출력하는데 맨 아래쪽에 전체 토탈월급도 출력하시오!

select to_char(hiredate , 'rrrr') , sum(sal)
from emp
group by to_char(hiredate , 'rrrr')
union all
select '토탈' , sum(sal)
from emp;


문제138.
*select 문장에서 
 subquery 를 쓸수있는절

select	--scalar(확장된) subquery쓸수 있음
from    --in line view (from의 서브쿼리)
where   --subquery쓸수 있음
group by
having  --subquery쓸수 있음
order by--scalar(확장된) subquery쓸수 있음

@in line view 즉 from절의 서브쿼리를 사용해야하는 이유

문제138. 사원이름, 월급, 월급에 대한 순위를 출력하시오(높은순에 대한 순위이다.)
(분석함수 rank를 활용해야됨)                분석함수 = 분석을 하는 함수
select ename, sal,
       rank() over (order by sal desc) 순위  <-3등이 나오진 않음....
from emp;

select ename, sal,
       dense_rank() over (order by sal desc) 순위 <-3등이 출력되도록 dense(밀집한의 뜻)
from emp;

문제139. rank함수를 이용해서 이름, 입사일, 순위를 출력하는데 순위가 먼저입사한 사원부터 순위를 부여하시오
select ename, hiredate,
       rank() over (order by hiredate asc) 순위
from emp;

문제140. 위의 결과에서 2등만 출력하시오.(from절의 서브쿼리를 사용)


3.select
1.from
2.where
순서로 실행되기 떄문에...

select ename, hiredate,
       rank() over (order by hiredate asc) 순위
from emp
where 순위 =3;
이렇게 하면안됨

select *
from( select ename, hiredate,
      rank() over (order by hiredate asc) 순위      괄호열과 프롬절에 그대로 쓰면된다!!! 프롬절부터 실행이 되니까!!
      from emp)
where 순위 =2;

문제141. 월급의 순위가 2등과 3등인 사원의 이름과 월급과 순위를 출력하시오!

select *
from( select ename, sal,
      dense_rank() over (order by sal desc) 순위      
      from emp)
where 순위 =2 or 순위=3;

문제142.부서번호, 이름, 월급, 순위를 출력하는데 부서번호별로 각각 월급이 높은 순서로 순위를부여하시오
select deptno, ename, sal,
       dense_rank() over (partition by deptno
                          order by sal desc) 순위
from emp;


문제143. 직업,이름, 입사일, 순위를 출력하는데 순위는 직업별로 각각 먼저 입사한 사원에 대한 순위인데
         직업별로 각각 2등만출력하시오

select *
from(select job, ename, hiredate,
     dense_rank() over (partition by job
                        order by hiredate asc) 순위
     from emp)
where 순위 =2;

문제144. (기말고사문제) DALLAS에서 월급을 2번째로 많이 받는 사원의 이름과 부서위치와 월급과 순위를 출력하시오

select *
from(select e.ename, d.loc, e.sal,
     dense_rank() over (order by sal desc) 순위
     from emp e, dept d
     where e.deptno = d.deptno and d.loc='DALLAS')
where  순위 = 2;

select *
from(select e.ename, d.loc, e.sal,
     dense_rank() over (partition by d.loc
                        order by sal desc) 순위
     from emp e, dept d
     where e.deptno = d.deptno)
where  loc='DALLAS' and 순위 = 2;  <-d.loc라고 하면안됨..... 실제로 나올떄 컬럼명이 ename, loc, sal로 나오니까 loc라고 해야된다!



문제145. 입사한 년도를 뽑고(4자리), 이름, 월급,  순위를 출력하는데 순위가 입사한 년도별로 각각 월급이 높은순서데로 순위를 부여하시오!

select to_char(hiredate, 'rrrr'), ename, sal,
     dense_rank() over (partition by  to_char(hiredate, 'rrrr')
                        order by sal desc) 순위
     from emp ;
 
과제: 월급 2450 인 사원의 월급의 순위는 어떻게 되는가? 



select *
from  (select sal, dense_rank() over (order by sal desc) 순위
       from emp)
where sal = 2450;




문제146.(마지막문제) 부서명 RESEARCH에서 2번째로 입사한 사원의 이름과 입사일과 부서명을 출력하시오

select *
from(select e.ename, e.hiredate, d.dname,
     dense_rank() over (partition by d.dname
                        order by hiredate asc) 순위
     from emp e, dept d
     where e.deptno = d.deptno and d.dname ='RESEARCH')
where 순위 = 2;












































































































































